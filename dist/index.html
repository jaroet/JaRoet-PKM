<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JaRoet PKM</title>
    
    <!-- Tailwind CSS (via CDN) -->
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            colors: {
              background: 'var(--background)',
              foreground: 'var(--foreground)',
              card: 'var(--card)',
              'card-foreground': 'var(--card-foreground)',
              primary: 'var(--primary)',
              'primary-foreground': 'var(--primary-foreground)',
            }
          }
        }
      }
    </script>
    
    <!-- App Styles -->
    <style>
      :root {
        --background: #f8fafc;
        --foreground: #0f172a;
        --card: #ffffff;
        --card-foreground: #0f172a;
        --primary: #3b82f6;
        --primary-foreground: #ffffff;
        --scrollbar-thumb: #94a3b8;
      }
      .dark {
        --background: #0f172a;
        --foreground: #f8fafc;
        --card: #1e293b;
        --card-foreground: #f8fafc;
        --primary: #60a5fa;
        --primary-foreground: #0f172a;
        --scrollbar-thumb: #475569;
      }
      body {
        background-color: var(--background);
        color: var(--foreground);
        transition: background-color 0.3s, color 0.3s;
      }
      
      /* Custom Scrollbar Styles */
      .custom-scrollbar {
        scrollbar-width: thin;
        scrollbar-color: var(--scrollbar-thumb) transparent;
      }
      
      .custom-scrollbar::-webkit-scrollbar {
        width: 12px;
        height: 12px;
        display: block;
      }
      
      .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
      }
      
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: var(--scrollbar-thumb);
        border-radius: 6px;
        border: 3px solid transparent;
        background-clip: content-box;
      }
      
      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background-color: var(--primary);
      }
      
      .custom-scrollbar::-webkit-scrollbar-corner {
        background: transparent;
      }
    </style>
    
    <!-- Libraries -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.js"></script>
    <script src="https://unpkg.com/marked@9.1.2/marked.min.js"></script>
    <!-- Babel for on-the-fly compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript">
        // --- React Hooks & Global Shims ---
        const { useState, useEffect, useRef, useCallback } = React;
        
        // --- Configure Marked for External Links ---
        const renderer = new marked.Renderer();
        const originalLink = renderer.link;
        renderer.link = function(href, title, text) {
            const isExternal = href && (href.startsWith('http') || href.startsWith('//'));
            const target = isExternal ? ' target="_blank" rel="noopener noreferrer"' : '';
            const titleAttr = title ? ` title="${title}"` : '';
            
            let output = `<a href="${href}"${titleAttr}${target}>${text}`;
            
            if (isExternal) {
                 output += '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block ml-0.5 opacity-70 mb-0.5 align-baseline"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>';
            }
            output += '</a>';
            return output;
        };
        marked.use({ renderer });

        // --- 1. Types ---
        
        interface Note {
          id: string;
          title: string;
          content: string;
          linksTo: string[];   // Downers (Children)
          relatedTo: string[]; // Lefters (Lateral)
          isFavorite: boolean;
          createdAt: number;
          modifiedAt: number;
        }

        type Section = 'center' | 'up' | 'down' | 'left' | 'right' | 'favs' | 'content';

        interface Topology {
          center: Note | null;
          uppers: Note[];
          downers: Note[];
          lefters: Note[];
          righters: Note[];
        }

        interface SearchResult {
          id: string;
          title: string;
        }

        type Theme = 'light' | 'dark';

        interface Point {
          x: number;
          y: number;
        }

        interface Connection {
          from: Point;
          to: Point;
          type: 'hierarchical' | 'lateral';
        }

        // --- 2. Database Services ---
        
        // Dexie is available globally as 'Dexie'

        // --- Vault Management ---

        const VAULT_LIST_KEY = 'nexusnode_vaults';
        const CURRENT_VAULT_KEY = 'nexusnode_current_vault';
        const DEFAULT_VAULT = 'JaRoet-PKM';

        if (!localStorage.getItem(VAULT_LIST_KEY)) {
            localStorage.setItem(VAULT_LIST_KEY, JSON.stringify([DEFAULT_VAULT]));
        }
        if (!localStorage.getItem(CURRENT_VAULT_KEY)) {
            localStorage.setItem(CURRENT_VAULT_KEY, DEFAULT_VAULT);
        }

        const getVaultList = () => {
            try {
                return JSON.parse(localStorage.getItem(VAULT_LIST_KEY) || '[]');
            } catch {
                return [DEFAULT_VAULT];
            }
        };

        const getCurrentVaultName = () => {
            return localStorage.getItem(CURRENT_VAULT_KEY) || DEFAULT_VAULT;
        };

        // --- Database Class ---

        class PKMDatabase extends Dexie {
          // Type shim for TS in Babel
          notes;
          meta;

          constructor() {
            super(getCurrentVaultName());
            this.version(1).stores({
              notes: 'id, title, *linksTo, *relatedTo', 
              meta: 'key',
            });
          }
        }

        const db = new PKMDatabase();

        // --- Vault Operations ---

        const switchVault = (name) => {
            if (getVaultList().includes(name)) {
                localStorage.setItem(CURRENT_VAULT_KEY, name);
                window.location.reload();
            }
        };

        const createVault = (name) => {
            const list = getVaultList();
            const sanitizedName = name.trim();
            if (sanitizedName && !list.includes(sanitizedName)) {
                list.push(sanitizedName);
                localStorage.setItem(VAULT_LIST_KEY, JSON.stringify(list));
                localStorage.setItem(CURRENT_VAULT_KEY, sanitizedName); 
                window.location.reload();
            }
        };

        const deleteCurrentVault = async () => {
            const current = getCurrentVaultName();
            db.close();
            await Dexie.delete(current);
            let list = getVaultList();
            list = list.filter(v => v !== current);
            if (list.length === 0) list.push(DEFAULT_VAULT);
            localStorage.setItem(VAULT_LIST_KEY, JSON.stringify(list));
            localStorage.setItem(CURRENT_VAULT_KEY, list[0]); 
            window.location.reload();
        };

        const resetCurrentVault = async () => {
            await db.transaction('rw', db.notes, db.meta, async () => {
                await db.notes.clear();
                await db.meta.clear();
            });
            window.location.reload();
        };

        // --- Seed Data ---
        const seedDatabase = async () => {
          const count = await db.notes.count();
          if (count === 0) {
            const now = Date.now();
            const n1 = {
              id: crypto.randomUUID(),
              title: 'Welcome to JaRoet PKM',
              content: '# Welcome\n\nThis is your Central Note. Use arrow keys to navigate.',
              linksTo: [],
              relatedTo: [],
              isFavorite: false,
              createdAt: now,
              modifiedAt: now,
            };
            
            await db.notes.bulkAdd([n1]);
            await db.meta.put({ key: 'currentCentralNoteId', value: n1.id });
            await db.meta.put({ key: 'favoritesList', value: [] });
            await db.meta.put({ key: 'homeNoteId', value: n1.id });
            return n1.id;
          }
          return null;
        };

        // --- Core Operations ---

        const getNote = async (id) => {
          return await db.notes.get(id);
        };

        const createNote = async (title) => {
          const now = Date.now();
          const note = {
            id: crypto.randomUUID(),
            title,
            content: '',
            linksTo: [],
            relatedTo: [],
            isFavorite: false,
            createdAt: now,
            modifiedAt: now,
          };
          await db.notes.add(note);
          return note;
        };

        const updateNote = async (id, updates) => {
          await db.notes.update(id, { ...updates, modifiedAt: Date.now() });
        };

        const deleteNote = async (id) => {
            await db.transaction('rw', db.notes, db.meta, async () => {
                await db.notes.delete(id);
                await db.notes.where('linksTo').equals(id).modify((note) => {
                    note.linksTo = note.linksTo.filter(linkId => linkId !== id);
                    note.modifiedAt = Date.now();
                });
                await db.notes.where('relatedTo').equals(id).modify((note) => {
                    note.relatedTo = note.relatedTo.filter(linkId => linkId !== id);
                    note.modifiedAt = Date.now();
                });
                const favsMeta = await db.meta.get('favoritesList');
                if (favsMeta && favsMeta.value.includes(id)) {
                    const newFavs = favsMeta.value.filter((favId) => favId !== id);
                    await db.meta.put({ key: 'favoritesList', value: newFavs });
                }
            });
        };

        const getNoteCount = async () => {
            return await db.notes.count();
        };

        // --- Topology ---

        const getTopology = async (centerId) => {
          const center = await db.notes.get(centerId);
          if (!center) {
            return { center: null, uppers: [], downers: [], lefters: [], righters: [] };
          }
          const uppers = await db.notes.where('linksTo').equals(centerId).toArray();
          const downers = await db.notes.bulkGet(center.linksTo);
          const lefters = await db.notes.bulkGet(center.relatedTo);
          const rightersMap = new Map();
          for (const upper of uppers) {
            const siblings = await db.notes.bulkGet(upper.linksTo);
            siblings.forEach(sib => {
              if (sib && sib.id !== centerId) {
                rightersMap.set(sib.id, sib);
              }
            });
          }
          const righters = Array.from(rightersMap.values());
          return {
            center,
            uppers: uppers.filter(Boolean),
            downers: downers.filter(Boolean),
            lefters: lefters.filter(Boolean),
            righters,
          };
        };

        // --- Favorites ---

        const getFavorites = async () => {
          const meta = await db.meta.get('favoritesList');
          const ids = meta ? meta.value : [];
          const notes = await db.notes.bulkGet(ids);
          return notes.filter(Boolean);
        };

        const toggleFavorite = async (noteId) => {
          await db.transaction('rw', db.notes, db.meta, async () => {
            const note = await db.notes.get(noteId);
            if (!note) return;
            const newStatus = !note.isFavorite;
            await db.notes.update(noteId, { isFavorite: newStatus, modifiedAt: Date.now() });
            const meta = await db.meta.get('favoritesList');
            let ids = meta ? meta.value : [];
            if (newStatus) {
              if (!ids.includes(noteId)) ids.push(noteId);
            } else {
              ids = ids.filter(id => id !== noteId);
            }
            await db.meta.put({ key: 'favoritesList', value: ids });
          });
        };

        // --- Home Note ---

        const getHomeNoteId = async () => {
            const meta = await db.meta.get('homeNoteId');
            return meta ? meta.value : null;
        };

        const setHomeNoteId = async (id) => {
            await db.meta.put({ key: 'homeNoteId', value: id });
        };

        // --- Settings ---

        const getFontSize = async () => {
            const meta = await db.meta.get('fontSize');
            return meta ? meta.value : 16;
        };

        const setFontSize = async (size) => {
            await db.meta.put({ key: 'fontSize', value: size });
        };

        const getSectionVisibility = async () => {
            const fav = await db.meta.get('ui_showFavorites');
            const cont = await db.meta.get('ui_showContent');
            return {
                showFavorites: fav !== undefined ? fav.value : true,
                showContent: cont !== undefined ? cont.value : true
            };
        };

        const setSectionVisibility = async (key, value) => {
            await db.meta.put({ key: `ui_${key}`, value });
        };

        interface ThemeConfig {
            background: string;
            section: string;
            accent: string;
            bars: string;
        }

        interface AppTheme {
            light: ThemeConfig;
            dark: ThemeConfig;
        }

        const DEFAULT_THEME = {
            light: {
                background: '#f1f5f9',
                section: '#ffffff',
                accent: '#3b82f6',
                bars: '#e2e8f0'
            },
            dark: {
                background: '#1e293b',
                section: '#0f172a',
                accent: '#60a5fa',
                bars: '#0f172a'
            }
        };

        const getAppTheme = async () => {
            const meta = await db.meta.get('appTheme');
            if (meta && meta.value) {
                return meta.value;
            }
            return DEFAULT_THEME;
        };

        const setAppTheme = async (theme) => {
            await db.meta.put({ key: 'appTheme', value: theme });
        };

        // --- Search ---

        const searchNotes = async (query) => {
          if (!query) return [];
          const q = query.toLowerCase();
          return await db.notes
            .filter(n => n.title.toLowerCase().includes(q))
            .toArray()
            .then(notes => notes.map(n => ({ id: n.id, title: n.title })));
        };

        const getAllNotes = async () => {
          return await db.notes.toArray();
        };

        const importNotes = async (notes) => {
          await db.notes.clear();
          const CHUNK_SIZE = 50; 
          for (let i = 0; i < notes.length; i += CHUNK_SIZE) {
            const chunk = notes.slice(i, i + CHUNK_SIZE);
            await db.notes.bulkAdd(chunk);
            await new Promise(resolve => setTimeout(resolve, 10));
          }
          const favorites = notes.filter(n => n.isFavorite).map(n => n.id);
          await db.meta.put({ key: 'favoritesList', value: favorites });
          if (notes.length > 0) {
              await db.meta.put({ key: 'currentCentralNoteId', value: notes[0].id });
              await db.meta.put({ key: 'homeNoteId', value: notes[0].id });
          }
        };

        // --- 2b. Journal Service ---
        const journalDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const journalMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

        const formatJournalDate = (d) => {
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            const dayName = journalDays[d.getDay()];
            const monthName = journalMonths[d.getMonth()];
            
            return {
                full: `${yyyy}-${mm}-${dd} (${dayName})`,
                month: `${yyyy}-${mm} (${monthName})`,
                year: `Journal ${yyyy}`,
            };
        };

        const findNoteByExactTitle = async (title) => {
            const results = await searchNotes(title);
            const match = results.find(r => r.title.toLowerCase() === title.toLowerCase());
            if (match) return await getNote(match.id);
            return undefined;
        };

        const goToToday = async () => {
            const now = new Date();
            const dateInfo = formatJournalDate(now);
            
            // 1. Ensure Hub
            let hub = await findNoteByExactTitle('Journal Hub');
            if (!hub) {
                hub = await createNote('Journal Hub');
                await updateNote(hub.id, { 
                    content: '# Journal Hub\n\nThe root of your chronological journey.',
                    isFavorite: true 
                });
            }

            // 2. Ensure Year
            let yearNote = await findNoteByExactTitle(dateInfo.year);
            if (!yearNote) {
                yearNote = await createNote(dateInfo.year);
                const freshHub = await getNote(hub.id);
                if (freshHub && !freshHub.linksTo.includes(yearNote.id)) {
                    await updateNote(hub.id, { linksTo: [...freshHub.linksTo, yearNote.id] });
                }
            }

            // 3. Ensure Month
            let monthNote = await findNoteByExactTitle(dateInfo.month);
            if (!monthNote) {
                monthNote = await createNote(dateInfo.month);
                const freshYear = await getNote(yearNote.id);
                if (freshYear && !freshYear.linksTo.includes(monthNote.id)) {
                    await updateNote(yearNote.id, { linksTo: [...freshYear.linksTo, monthNote.id] });
                }
            }

            // 4. Ensure Today
            let dayNote = await findNoteByExactTitle(dateInfo.full);
            if (!dayNote) {