<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JaRoet PKM</title>
    
    <!-- Tailwind CSS (via CDN) -->
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            colors: {
              background: 'var(--background)',
              foreground: 'var(--foreground)',
              card: 'var(--card)',
              'card-foreground': 'var(--card-foreground)',
              primary: 'var(--primary)',
              'primary-foreground': 'var(--primary-foreground)',
            }
          }
        }
      }
    </script>
    
    <!-- App Styles -->
    <style>
      :root {
        --background: #f8fafc;
        --foreground: #0f172a;
        --card: #ffffff;
        --card-foreground: #0f172a;
        --primary: #3b82f6;
        --primary-foreground: #ffffff;
        --scrollbar-thumb: #94a3b8;
      }
      .dark {
        --background: #0f172a;
        --foreground: #f8fafc;
        --card: #1e293b;
        --card-foreground: #f8fafc;
        --primary: #60a5fa;
        --primary-foreground: #0f172a;
        --scrollbar-thumb: #475569;
      }
      body {
        background-color: var(--background);
        color: var(--foreground);
        transition: background-color 0.3s, color 0.3s;
      }
      
      /* Custom Scrollbar Styles */
      .custom-scrollbar {
        scrollbar-width: thin;
        scrollbar-color: var(--scrollbar-thumb) transparent;
      }
      
      .custom-scrollbar::-webkit-scrollbar {
        width: 12px;
        height: 12px;
        display: block;
      }
      
      .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
      }
      
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: var(--scrollbar-thumb);
        border-radius: 6px;
        border: 3px solid transparent;
        background-clip: content-box;
      }
      
      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background-color: var(--primary);
      }
      
      .custom-scrollbar::-webkit-scrollbar-corner {
        background: transparent;
      }
    </style>
    
    <!-- Libraries -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.js"></script>
    <script src="https://unpkg.com/marked@9.1.2/marked.min.js"></script>
    <!-- Babel for on-the-fly compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript">
        // --- React Hooks & Global Shims ---
        const { useState, useEffect, useRef, useCallback } = React;
        
        // --- Configure Marked for External Links (Global) ---
        const renderer = new marked.Renderer();
        const originalLink = renderer.link;
        renderer.link = function(href, title, text) {
            const isExternal = href && (href.startsWith('http') || href.startsWith('//'));
            const target = isExternal ? ' target="_blank" rel="noopener noreferrer"' : '';
            const titleAttr = title ? ` title="${title}"` : '';
            
            let output = `<a href="${href}"${titleAttr}${target}>${text}`;
            
            if (isExternal) {
                 output += '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block ml-0.5 opacity-70 mb-0.5 align-baseline"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>';
            }
            output += '</a>';
            return output;
        };
        // Global renderer has disabled checkboxes (for main view)
        renderer.checkbox = function(checked) {
            return `<input type="checkbox" ${checked ? 'checked="" ' : ''} class="task-list-item-checkbox" disabled>`;
        };
        marked.use({ renderer });

        // --- Editor Specific Renderer ---
        const editorRenderer = new marked.Renderer();
        editorRenderer.link = renderer.link; // Re-use link logic
        // Editor renderer has enabled checkboxes with pointer cursor and spacing
        editorRenderer.checkbox = function(checked) {
            return `<input type="checkbox" ${checked ? 'checked="" ' : ''} class="task-list-item-checkbox" style="cursor: pointer; margin-right: 0.6em; vertical-align: middle;">`;
        };

        // --- 1. Types ---
        
        interface Note {
          id: string;
          title: string;
          content: string;
          linksTo: string[];   // Downers (Children)
          relatedTo: string[]; // Lefters (Lateral)
          isFavorite: boolean;
          createdAt: number;
          modifiedAt: number;
        }

        type Section = 'center' | 'up' | 'down' | 'left' | 'right' | 'favs' | 'content';

        interface Topology {
          center: Note | null;
          uppers: Note[];
          downers: Note[];
          lefters: Note[];
          righters: Note[];
        }

        interface SearchResult {
          id: string;
          title: string;
        }

        type Theme = 'light' | 'dark';

        interface Point {
          x: number;
          y: number;
        }

        interface Connection {
          from: Point;
          to: Point;
          type: 'hierarchical' | 'lateral';
        }

        // --- 2. Database Services ---
        
        // Dexie is available globally as 'Dexie'

        // --- Vault Management ---

        const VAULT_LIST_KEY = 'nexusnode_vaults';
        const CURRENT_VAULT_KEY = 'nexusnode_current_vault';
        const DEFAULT_VAULT = 'JaRoet-PKM';

        if (!localStorage.getItem(VAULT_LIST_KEY)) {
            localStorage.setItem(VAULT_LIST_KEY, JSON.stringify([DEFAULT_VAULT]));
        }
        if (!localStorage.getItem(CURRENT_VAULT_KEY)) {
            localStorage.setItem(CURRENT_VAULT_KEY, DEFAULT_VAULT);
        }

        const getVaultList = () => {
            try {
                return JSON.parse(localStorage.getItem(VAULT_LIST_KEY) || '[]');
            } catch {
                return [DEFAULT_VAULT];
            }
        };

        const getCurrentVaultName = () => {
            return localStorage.getItem(CURRENT_VAULT_KEY) || DEFAULT_VAULT;
        };

        // --- Database Class ---

        class PKMDatabase extends Dexie {
          // Type shim for TS in Babel
          notes;
          meta;

          constructor() {
            super(getCurrentVaultName());
            this.version(1).stores({
              notes: 'id, title, *linksTo, *relatedTo', 
              meta: 'key',
            });
          }
        }

        const db = new PKMDatabase();

        // --- Vault Operations ---

        const switchVault = (name) => {
            if (getVaultList().includes(name)) {
                localStorage.setItem(CURRENT_VAULT_KEY, name);
                window.location.reload();
            }
        };

        const createVault = (name) => {
            const list = getVaultList();
            const sanitizedName = name.trim();
            if (sanitizedName && !list.includes(sanitizedName)) {
                list.push(sanitizedName);
                localStorage.setItem(VAULT_LIST_KEY, JSON.stringify(list));
                localStorage.setItem(CURRENT_VAULT_KEY, sanitizedName); 
                window.location.reload();
            }
        };

        const deleteCurrentVault = async () => {
            const current = getCurrentVaultName();
            db.close();
            await Dexie.delete(current);
            let list = getVaultList();
            list = list.filter(v => v !== current);
            if (list.length === 0) list.push(DEFAULT_VAULT);
            localStorage.setItem(VAULT_LIST_KEY, JSON.stringify(list));
            localStorage.setItem(CURRENT_VAULT_KEY, list[0]); 
            window.location.reload();
        };

        const resetCurrentVault = async () => {
            await db.transaction('rw', db.notes, db.meta, async () => {
                await db.notes.clear();
                await db.meta.clear();
            });
            window.location.reload();
        };

        // --- Seed Data ---
        const seedDatabase = async () => {
          const count = await db.notes.count();
          if (count === 0) {
            const now = Date.now();
            const n1 = {
              id: crypto.randomUUID(),
              title: 'Welcome to JaRoet PKM',
              content: '# Welcome\n\nThis is your Central Note. Use arrow keys to navigate.',
              linksTo: [],
              relatedTo: [],
              isFavorite: false,
              createdAt: now,
              modifiedAt: now,
            };
            
            await db.notes.bulkAdd([n1]);
            await db.meta.put({ key: 'currentCentralNoteId', value: n1.id });
            await db.meta.put({ key: 'favoritesList', value: [] });
            await db.meta.put({ key: 'homeNoteId', value: n1.id });
            return n1.id;
          }
          return null;
        };

        // --- Core Operations ---

        const getNote = async (id) => {
          return await db.notes.get(id);
        };

        const createNote = async (title) => {
          const now = Date.now();
          const note = {
            id: crypto.randomUUID(),
            title,
            content: '',
            linksTo: [],
            relatedTo: [],
            isFavorite: false,
            createdAt: now,
            modifiedAt: now,
          };
          await db.notes.add(note);
          return note;
        };

        const updateNote = async (id, updates) => {
          await db.notes.update(id, { ...updates, modifiedAt: Date.now() });
        };

        const deleteNote = async (id) => {
            await db.transaction('rw', db.notes, db.meta, async () => {
                await db.notes.delete(id);
                await db.notes.where('linksTo').equals(id).modify((note) => {
                    note.linksTo = note.linksTo.filter(linkId => linkId !== id);
                    note.modifiedAt = Date.now();
                });
                await db.notes.where('relatedTo').equals(id).modify((note) => {
                    note.relatedTo = note.relatedTo.filter(linkId => linkId !== id);
                    note.modifiedAt = Date.now();
                });
                const favsMeta = await db.meta.get('favoritesList');
                if (favsMeta && favsMeta.value.includes(id)) {
                    const newFavs = favsMeta.value.filter((favId) => favId !== id);
                    await db.meta.put({ key: 'favoritesList', value: newFavs });
                }
            });
        };

        const getNoteCount = async () => {
            return await db.notes.count();
        };

        // --- Topology ---

        const getTopology = async (centerId) => {
          const center = await db.notes.get(centerId);
          if (!center) {
            return { center: null, uppers: [], downers: [], lefters: [], righters: [] };
          }
          const uppers = await db.notes.where('linksTo').equals(centerId).toArray();
          const downers = await db.notes.bulkGet(center.linksTo);
          const lefters = await db.notes.bulkGet(center.relatedTo);
          const rightersMap = new Map();
          for (const upper of uppers) {
            const siblings = await db.notes.bulkGet(upper.linksTo);
            siblings.forEach(sib => {
              if (sib && sib.id !== centerId) {
                rightersMap.set(sib.id, sib);
              }
            });
          }
          const righters = Array.from(rightersMap.values());
          return {
            center,
            uppers: uppers.filter(Boolean),
            downers: downers.filter(Boolean),
            lefters: lefters.filter(Boolean),
            righters,
          };
        };

        // --- Favorites ---

        const getFavorites = async () => {
          const meta = await db.meta.get('favoritesList');
          const ids = meta ? meta.value : [];
          const notes = await db.notes.bulkGet(ids);
          return notes.filter(Boolean);
        };

        const toggleFavorite = async (noteId) => {
          await db.transaction('rw', db.notes, db.meta, async () => {
            const note = await db.notes.get(noteId);
            if (!note) return;
            const newStatus = !note.isFavorite;
            await db.notes.update(noteId, { isFavorite: newStatus, modifiedAt: Date.now() });
            const meta = await db.meta.get('favoritesList');
            let ids = meta ? meta.value : [];
            if (newStatus) {
              if (!ids.includes(noteId)) ids.push(noteId);
            } else {
              ids = ids.filter(id => id !== noteId);
            }
            await db.meta.put({ key: 'favoritesList', value: ids });
          });
        };

        // --- Home Note ---

        const getHomeNoteId = async () => {
            const meta = await db.meta.get('homeNoteId');
            return meta ? meta.value : null;
        };

        const setHomeNoteId = async (id) => {
            await db.meta.put({ key: 'homeNoteId', value: id });
        };

        // --- Settings ---

        const getFontSize = async () => {
            const meta = await db.meta.get('fontSize');
            return meta ? meta.value : 16;
        };

        const setFontSize = async (size) => {
            await db.meta.put({ key: 'fontSize', value: size });
        };

        const getSectionVisibility = async () => {
            const fav = await db.meta.get('ui_showFavorites');
            const cont = await db.meta.get('ui_showContent');
            return {
                showFavorites: fav !== undefined ? fav.value : true,
                showContent: cont !== undefined ? cont.value : true
            };
        };

        const setSectionVisibility = async (key, value) => {
            await db.meta.put({ key: `ui_${key}`, value });
        };

        interface ThemeConfig {
            background: string;
            section: string;
            accent: string;
            bars: string;
        }

        interface AppTheme {
            light: ThemeConfig;
            dark: ThemeConfig;
        }

        const DEFAULT_THEME = {
            light: {
                background: '#f1f5f9',
                section: '#ffffff',
                accent: '#3b82f6',
                bars: '#e2e8f0'
            },
            dark: {
                background: '#1e293b',
                section: '#0f172a',
                accent: '#60a5fa',
                bars: '#0f172a'
            }
        };

        const getAppTheme = async () => {
            const meta = await db.meta.get('appTheme');
            if (meta && meta.value) {
                return meta.value;
            }
            return DEFAULT_THEME;
        };

        const setAppTheme = async (theme) => {
            await db.meta.put({ key: 'appTheme', value: theme });
        };

        // --- Search ---

        const searchNotes = async (query) => {
          if (!query) return [];
          const q = query.toLowerCase();
          return await db.notes
            .filter(n => n.title.toLowerCase().includes(q))
            .toArray()
            .then(notes => notes.map(n => ({ id: n.id, title: n.title })));
        };

        const getAllNotes = async () => {
          return await db.notes.toArray();
        };

        const importNotes = async (notes) => {
          await db.notes.clear();
          const CHUNK_SIZE = 50; 
          for (let i = 0; i < notes.length; i += CHUNK_SIZE) {
            const chunk = notes.slice(i, i + CHUNK_SIZE);
            await db.notes.bulkAdd(chunk);
            await new Promise(resolve => setTimeout(resolve, 10));
          }
          const favorites = notes.filter(n => n.isFavorite).map(n => n.id);
          await db.meta.put({ key: 'favoritesList', value: favorites });
          if (notes.length > 0) {
              await db.meta.put({ key: 'currentCentralNoteId', value: notes[0].id });
              await db.meta.put({ key: 'homeNoteId', value: notes[0].id });
          }
        };

        // --- 2b. Journal Service ---
        const journalDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const journalMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

        const formatJournalDate = (d) => {
            const yyyy = d.getFullYear();
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            const dayName = journalDays[d.getDay()];
            const monthName = journalMonths[d.getMonth()];
            
            return {
                full: `${yyyy}-${mm}-${dd} (${dayName})`,
                month: `${yyyy}-${mm} (${monthName})`,
                year: `Journal ${yyyy}`,
            };
        };

        const findNoteByExactTitle = async (title) => {
            const results = await searchNotes(title);
            const match = results.find(r => r.title.toLowerCase() === title.toLowerCase());
            if (match) return await getNote(match.id);
            return undefined;
        };

        const goToToday = async () => {
            const now = new Date();
            const dateInfo = formatJournalDate(now);
            
            // 1. Ensure Hub
            let hub = await findNoteByExactTitle('Journal Hub');
            if (!hub) {
                hub = await createNote('Journal Hub');
                await updateNote(hub.id, { 
                    content: '# Journal Hub\n\nThe root of your chronological journey.',
                    isFavorite: true 
                });
            }

            // 2. Ensure Year
            let yearNote = await findNoteByExactTitle(dateInfo.year);
            if (!yearNote) {
                yearNote = await createNote(dateInfo.year);
                const freshHub = await getNote(hub.id);
                if (freshHub && !freshHub.linksTo.includes(yearNote.id)) {
                    await updateNote(hub.id, { linksTo: [...freshHub.linksTo, yearNote.id] });
                }
            }

            // 3. Ensure Month
            let monthNote = await findNoteByExactTitle(dateInfo.month);
            if (!monthNote) {
                monthNote = await createNote(dateInfo.month);
                const freshYear = await getNote(yearNote.id);
                if (freshYear && !freshYear.linksTo.includes(monthNote.id)) {
                    await updateNote(yearNote.id, { linksTo: [...freshYear.linksTo, monthNote.id] });
                }
            }

            // 4. Ensure Today
            let dayNote = await findNoteByExactTitle(dateInfo.full);
            if (!dayNote) {
                dayNote = await createNote(dateInfo.full);
                // Empty content per request

                const freshMonth = await getNote(monthNote.id);
                if (freshMonth && !freshMonth.linksTo.includes(dayNote.id)) {
                    await updateNote(monthNote.id, { linksTo: [...freshMonth.linksTo, dayNote.id] });
                }

                // 5. Link Yesterday
                const yesterdayDate = new Date(now);
                yesterdayDate.setDate(yesterdayDate.getDate() - 1);
                const yInfo = formatJournalDate(yesterdayDate);
                const yesterdayNote = await findNoteByExactTitle(yInfo.full);
                
                if (yesterdayNote) {
                    const freshDay = await getNote(dayNote.id);
                    const freshYesterday = await getNote(yesterdayNote.id);
                    if (freshDay && freshYesterday) {
                        if (!freshDay.relatedTo.includes(yesterdayNote.id)) {
                            await updateNote(freshDay.id, { relatedTo: [...freshDay.relatedTo, yesterdayNote.id] });
                        }
                        if (!freshYesterday.relatedTo.includes(freshDay.id)) {
                            await updateNote(freshYesterday.id, { relatedTo: [...freshYesterday.relatedTo, freshDay.id] });
                        }
                    }
                }

                // 6. Link Past Years
                for (let i = 1; i <= 5; i++) {
                    const pastDate = new Date(now);
                    pastDate.setFullYear(pastDate.getFullYear() - i);
                    const pInfo = formatJournalDate(pastDate);
                    const pastNote = await findNoteByExactTitle(pInfo.full);
                    if (pastNote) {
                        const freshDay = await getNote(dayNote.id);
                        const freshPast = await getNote(pastNote.id);
                        if (freshDay && freshPast) {
                             if (!freshDay.relatedTo.includes(pastNote.id)) {
                                await updateNote(freshDay.id, { relatedTo: [...freshDay.relatedTo, pastNote.id] });
                             }
                             if (!freshPast.relatedTo.includes(freshDay.id)) {
                                await updateNote(freshPast.id, { relatedTo: [...freshPast.relatedTo, freshDay.id] });
                             }
                        }
                    }
                }
            }

            return dayNote.id;
        };


        // --- 3. Components ---

        // -- NoteCard --
        const NoteCard = ({ note, isFocused, isSelected, isCenter, fontSize, onClick, className, id }) => {
            if (isCenter) {
              return (
                <div
                  id={id}
                  onClick={onClick}
                  className={`
                    relative flex flex-col items-center justify-center transition-all duration-200 cursor-pointer z-20
                    p-6 max-w-3xl text-center
                    ${className || ''}
                  `}
                >
                  <div 
                    style={{ 
                        fontSize: `${fontSize * 1.5}px`,
                        backgroundColor: isFocused ? 'color-mix(in srgb, var(--theme-accent) 20%, transparent)' : undefined,
                        boxShadow: isFocused ? '0 0 0 2px color-mix(in srgb, var(--theme-accent) 50%, transparent)' : undefined
                    }}
                    className={`
                      font-bold leading-tight select-none px-4 py-2 rounded-lg transition-all
                      ${isFocused ? 'backdrop-blur-sm shadow-sm' : ''}
                      text-foreground
                    `}
                  >
                    {note.title}
                  </div>
                </div>
              );
            }

            return (
              <div
                id={id}
                onClick={onClick}
                title={note.title}
                style={{ 
                    fontSize: `${fontSize}px`,
                    backgroundColor: isFocused 
                        ? 'color-mix(in srgb, var(--theme-accent) 20%, transparent)' 
                        : isSelected 
                            ? 'color-mix(in srgb, var(--theme-accent) 10%, transparent)'
                            : undefined,
            boxShadow: isFocused 
                        ? 'inset 0 0 0 2px color-mix(in srgb, var(--theme-accent) 50%, transparent)' 
                        : isSelected
                            ? 'inset 0 0 0 2px color-mix(in srgb, var(--theme-accent) 30%, transparent)'
                            : undefined
                }}
                className={`
                  relative group flex items-center
                  px-3 py-1.5 rounded-md cursor-pointer select-none transition-all duration-150
                  truncate flex-shrink-0 text-foreground
                  ${
                    isFocused
                      ? 'z-10 shadow-sm font-medium'
                      : 'hover:bg-foreground/5 opacity-90 hover:opacity-100'
                  }
                  ${className || ''}
                `}
              >
                <span className="truncate flex-1">{note.title}</span>
                {isSelected && (
                    <span className="absolute right-2 w-2 h-2 rounded-full bg-[var(--theme-accent)]"></span>
                )}
              </div>
            );
        };

        // -- LinkerModal --
        const LinkerModal = ({ isOpen, type, onClose, onSelect }) => {
          const [query, setQuery] = useState('');
          const [results, setResults] = useState([]);
          const [selectedIndex, setSelectedIndex] = useState(0);
          const inputRef = useRef(null);

          const isBulk = query.includes(';');

          useEffect(() => {
            if (isOpen) {
              setQuery('');
              setResults([]);
              setSelectedIndex(0);
              setTimeout(() => inputRef.current?.focus(), 50);
            }
          }, [isOpen]);

          useEffect(() => {
            const fetch = async () => {
              if (query.trim() && !isBulk) {
                const res = await searchNotes(query);
                setResults(res);
              } else {
                setResults([]);
              }
            };
            const debounce = setTimeout(fetch, 200);
            return () => clearTimeout(debounce);
          }, [query, isBulk]);

          const handleKeyDown = (e) => {
            if (e.key === 'ArrowDown') {
              e.preventDefault();
              if (!isBulk) {
                setSelectedIndex(prev => (prev + 1) % (results.length + 1));
              }
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              if (!isBulk) {
                setSelectedIndex(prev => (prev - 1 + (results.length + 1)) % (results.length + 1));
              }
            } else if (e.key === 'Enter') {
              e.preventDefault();
              if (isBulk) {
                if (query.trim()) {
                    onSelect(null, query);
                }
              } else {
                if (selectedIndex < results.length) {
                    onSelect(results[selectedIndex].id);
                } else {
                    if (query.trim()) {
                    onSelect(null, query);
                    }
                }
              }
              onClose();
            } else if (e.key === 'Escape') {
              onClose();
            }
          };

          if (!isOpen) return null;

          const titles = {
            up: 'Link Parent',
            down: 'Link Child',
            left: 'Link Related',
          };

          return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
              <div className="w-full max-w-md bg-background rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 p-4">
                <h3 className="text-lg font-semibold mb-2">{titles[type]}</h3>
                <p className="text-xs text-gray-500 mb-3">
                    Use <b>;</b> to separate multiple items (e.g. "Apple; Banana; Orange") for bulk creation.
                </p>
                <input
                  ref={inputRef}
                  type="text"
                  className="w-full p-2 rounded border border-gray-300 dark:border-gray-700 bg-background text-foreground focus:ring-2 focus:ring-primary outline-none"
                  placeholder="Search or type to create..."
                  value={query}
                  onChange={e => setQuery(e.target.value)}
                  onKeyDown={handleKeyDown}
                />
                <div className="mt-2 max-h-60 overflow-y-auto border-t border-gray-100 dark:border-gray-800 pt-2">
                  {isBulk ? (
                     <div
                        className="p-2 rounded cursor-pointer flex items-center gap-2 bg-primary text-primary-foreground"
                        onClick={() => {
                            onSelect(null, query);
                            onClose();
                        }}
                    >
                        <span className="font-bold">+</span> Bulk Create {query.split(';').filter(s => s.trim()).length} Notes
                    </div>
                  ) : (
                    <>
                        {results.map((res, idx) => (
                            <div
                            key={res.id}
                            className={`p-2 rounded cursor-pointer ${
                                idx === selectedIndex ? 'bg-primary text-primary-foreground' : 'hover:bg-gray-100 dark:hover:bg-gray-800'
                            }`}
                            onClick={() => {
                                onSelect(res.id);
                                onClose();
                            }}
                            >
                            {res.title}
                            </div>
                        ))}
                        {query.trim() && (
                            <div
                            className={`p-2 rounded cursor-pointer flex items-center gap-2 ${
                                selectedIndex === results.length ? 'bg-primary text-primary-foreground' : 'hover:bg-gray-100 dark:hover:bg-gray-800'
                            }`}
                            onClick={() => {
                                onSelect(null, query);
                                onClose();
                            }}
                            >
                            <span className="font-bold">+</span> Create "{query}"
                            </div>
                        )}
                    </>
                  )}
                </div>
              </div>
            </div>
          );
        };

        // -- MarkdownEditor --
        const MarkdownEditor = ({ note, isOpen, initialMode, onClose, onSave }) => {
          const [content, setContent] = useState('');
          const [parsedHtml, setParsedHtml] = useState('');
          const [isPreview, setIsPreview] = useState(initialMode === 'view');
          const textareaRef = useRef(null);
          const containerRef = useRef(null);
          const previewRef = useRef(null);

          // Initialize state when modal opens or note ID changes
          useEffect(() => {
            if (note && isOpen) {
              setContent(note.content || '');
              setIsPreview(initialMode === 'view');
              
              setTimeout(() => {
                  if (initialMode === 'view') {
                      previewRef.current?.focus();
                  } else {
                      const el = textareaRef.current;
                      if (el) {
                          el.focus();
                          // Move cursor to end
                          const len = el.value.length;
                          el.setSelectionRange(len, len);
                          el.scrollTop = el.scrollHeight;
              }
                  }
              }, 100);
            }
          }, [note?.id, isOpen]); 

          // Parse markdown whenever content changes
          useEffect(() => {
            const parse = async () => {
                try {
                    // Explicitly pass renderer to override any global config that disables checkboxes
                    const html = await marked.parse(content || '', { 
                        breaks: true, 
                        gfm: true,
                        renderer: editorRenderer 
                    });
                    setParsedHtml(html);
                } catch (e) {
                    console.error('Markdown parse error:', e);
                    setParsedHtml('<p>Error rendering markdown.</p>');
                }
            };
            const timeout = setTimeout(parse, 100);
            return () => clearTimeout(timeout);
          }, [content]);

          const toggleTask = (index) => {
            if (!note) return;
            // Regex to find tasks: matches "- [ ]", "* [x]", etc.
            const regex = /^(\s*[-*+]\s+\[)([ xX])(\])/gm;
            let currentIndex = 0;
            
            const newContent = content.replace(regex, (match, prefix, state, suffix) => {
                if (currentIndex === index) {
                    const newState = state === ' ' ? 'x' : ' ';
                    currentIndex++; 
                    return `${prefix}${newState}${suffix}`;
                }
                currentIndex++;
                return match;
            });

            if (newContent !== content) {
                setContent(newContent);
                onSave(note.id, newContent);
            }
          };

          const handlePreviewClick = (e) => {
              const target = e.target;
              if (target.tagName === 'INPUT' && target.type === 'checkbox') {
                   const checkboxes = previewRef.current?.querySelectorAll('input[type="checkbox"]');
                   if (checkboxes) {
                       const index = Array.from(checkboxes).indexOf(target);
                       if (index !== -1) {
                           toggleTask(index);
                       }
                   }
              }
          };

          const switchToEdit = () => {
              setIsPreview(false);
              setTimeout(() => {
                  const el = textareaRef.current;
                  if (el) {
                      el.focus();
                      const len = el.value.length;
                      el.setSelectionRange(len, len);
                      el.scrollTop = el.scrollHeight;
                  }
              }, 50);
          };

          const switchToView = () => {
              if (note) onSave(note.id, content);
              setIsPreview(true);
              setTimeout(() => previewRef.current?.focus(), 50);
          };

          const handleKeyDown = (e) => {
            e.stopPropagation(); // Stop global listeners

            if (e.key === 'Escape') {
              e.preventDefault();
              onClose();
              return;
            }
            
            // Ctrl+Enter
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (isPreview) {
                    switchToEdit();
                } else {
                    onClose();
                }
                return;
            }

            // Shift+Enter
            if (e.shiftKey && e.key === 'Enter' && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                if (isPreview) {
                    onClose();
                } else {
                    switchToView();
                }
                return;
            }
          };

          if (!isOpen || !note) return null;

          return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm p-4">
              <style>{`
                .editor-preview ul, .editor-preview ol {
                    margin-top: 0.25em !important;
                    margin-bottom: 0.25em !important;
                }
                .editor-preview li {
                    margin-top: 0 !important;
                    margin-bottom: 0 !important;
                }
                .editor-preview li > p {
                    margin-top: 0 !important;
                    margin-bottom: 0 !important;
                }
                .editor-preview li.task-list-item {
                    list-style-type: none;
                    padding-left: 0;
                }
              `}</style>

              <div 
                ref={containerRef}
                tabIndex={-1} 
                onKeyDown={handleKeyDown}
                className="w-full max-w-[90vw] h-[90vh] bg-[var(--theme-bg)] rounded-lg shadow-2xl flex flex-col border border-gray-200 dark:border-gray-800 outline-none"
              >
                <div className="flex justify-between items-center p-4 border-b dark:border-gray-700 bg-background/50 rounded-t-lg">
                  <h2 className="text-xl font-bold truncate pr-4">{note.title}</h2>
                  <div className="flex gap-2 flex-shrink-0">
                    <button
                      onClick={() => isPreview ? switchToEdit() : switchToView()}
                      title={isPreview ? "Switch to Edit (Ctrl+Enter)" : "Switch to View (Shift+Enter)"}
                      className="px-3 py-1 rounded bg-gray-200 dark:bg-gray-700 hover:opacity-80 text-sm min-w-[80px]"
                    >
                      {isPreview ? 'Edit' : 'Preview'}
                    </button>
                    {!isPreview && (
                        <button
                        onClick={() => {
                            onSave(note.id, content);
                            onClose();
                        }}
                        className="px-3 py-1 rounded bg-primary text-white hover:opacity-80 text-sm"
                        >
                        Save & Close
                        </button>
                    )}
                     <button
                      onClick={onClose}
                      title="Esc"
                      className="px-3 py-1 rounded bg-gray-200 dark:bg-gray-700 hover:opacity-80 text-sm"
                    >
                      Close
                    </button>
                  </div>
                </div>
                
                <div className="flex-1 overflow-hidden relative bg-background/50">
                    {isPreview ? (
                        <div 
                            ref={previewRef}
                            tabIndex={0}
                            onClick={handlePreviewClick}
                            style={{ fontSize: '15px' }}
                            className="editor-preview w-full h-full p-6 overflow-auto prose dark:prose-invert max-w-none custom-scrollbar select-text outline-none"
                            dangerouslySetInnerHTML={{ __html: parsedHtml }}
                        />
                    ) : (
                        <textarea
                            ref={textareaRef}
                            value={content}
                            onChange={(e) => setContent(e.target.value)}
                            style={{ fontSize: '15px' }}
                            className="w-full h-full p-6 bg-transparent resize-none outline-none font-mono custom-scrollbar"
                            placeholder="Type markdown here..."
                        />
                    )}
                </div>
                <div className="p-2 text-xs text-gray-500 border-t dark:border-gray-700 text-center bg-background/50 rounded-b-lg">
                    {isPreview 
                        ? 'View Mode • Ctrl+Enter: Edit • Shift+Enter: Close • Esc: Close' 
                        : 'Edit Mode • Shift+Enter: Save & View • Ctrl+Enter: Cancel & Close • Esc: Cancel & Close'
                    }
                </div>
              </div>
            </div>
          );
        };

        // -- RenameModal --
        const RenameModal = ({ isOpen, currentTitle, onClose, onRename }) => {
          const [title, setTitle] = useState(currentTitle);
          const inputRef = useRef(null);

          useEffect(() => {
            if (isOpen) {
              setTitle(currentTitle);
              setTimeout(() => inputRef.current?.focus(), 50);
            }
          }, [isOpen, currentTitle]);

          const handleSubmit = (e) => {
            e?.preventDefault();
            if (title.trim()) {
              onRename(title.trim());
              onClose();
            }
          };

          const handleKeyDown = (e) => {
              if (e.key === 'Escape') onClose();
          };

          if (!isOpen) return null;

          return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
              <div className="bg-background p-6 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 w-full max-w-md">
                <h3 className="text-lg font-bold mb-4">Rename Note</h3>
                <form onSubmit={handleSubmit}>
                  <input
                    ref={inputRef}
                    type="text"
                    value={title}
                    onChange={e => setTitle(e.target.value)}
                    onKeyDown={handleKeyDown}
                    className="w-full p-2 border border-gray-300 dark:border-gray-700 rounded bg-transparent focus:ring-2 focus:ring-primary outline-none mb-4 text-foreground"
                    placeholder="Note title..."
                  />
                  <div className="flex justify-end gap-2">
                    <button 
                        type="button" 
                        onClick={onClose} 
                        className="px-4 py-2 rounded hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors"
                    >
                        Cancel
                    </button>
                    <button 
                        type="submit" 
                        className="px-4 py-2 rounded bg-primary text-primary-foreground hover:opacity-90 transition-opacity"
                    >
                        Rename
                    </button>
                  </div>
                </form>
              </div>
            </div>
          );
        };

        // -- SettingsModal --
        const SettingsModal = ({ isOpen, onClose, currentCentralNoteId, fontSize, onFontSizeChange, onThemeChange, onSettingsChange }) => {
          const [activeTab, setActiveTab] = useState('general');
          const [themeMode, setThemeMode] = useState('dark');
          const [homeNoteTitle, setHomeNoteTitle] = useState('Loading...');
          const [searchQuery, setSearchQuery] = useState('');
          const [searchResults, setSearchResults] = useState([]);
          const [localFontSize, setLocalFontSize] = useState(fontSize);
          
          const [appTheme, setLocalAppTheme] = useState(null);
          const [showFavorites, setShowFavorites] = useState(true);
          const [showContent, setShowContent] = useState(true);
          
          const [newVaultName, setNewVaultName] = useState('');
          const [confirmDelete, setConfirmDelete] = useState(false);
          const [confirmReset, setConfirmReset] = useState(false);
          const [currentVault, setCurrentVault] = useState('');

          useEffect(() => {
            if (isOpen) {
              loadHomeNote();
              loadTheme();
              loadVisibility();
              setSearchQuery('');
              setSearchResults([]);
              setLocalFontSize(fontSize);
              setCurrentVault(getCurrentVaultName());
              setConfirmDelete(false);
              setConfirmReset(false);
              setNewVaultName('');
              setActiveTab('general');
            }
          }, [isOpen, fontSize]);

          const loadTheme = async () => {
              const t = await getAppTheme();
              setLocalAppTheme(t);
          };

          const loadVisibility = async () => {
              const v = await getSectionVisibility();
              setShowFavorites(v.showFavorites);
              setShowContent(v.showContent);
          };

          const loadHomeNote = async () => {
            const id = await getHomeNoteId();
            if (id) {
              const note = await getNote(id);
              setHomeNoteTitle(note ? note.title : 'Unknown Note');
            } else {
              setHomeNoteTitle('Not Set');
            }
          };

          const handleSearch = async (val) => {
            setSearchQuery(val);
            if (val.trim()) {
              const res = await searchNotes(val);
              setSearchResults(res);
            } else {
              setSearchResults([]);
            }
          };

          const setHome = async (id, title) => {
            await setHomeNoteId(id);
            setHomeNoteTitle(title);
            setSearchQuery('');
            setSearchResults([]);
          };

          const setCenterAsHome = async () => {
            if (currentCentralNoteId) {
                const note = await getNote(currentCentralNoteId);
                if (note) {
                    await setHome(note.id, note.title);
                }
            }
          };

          const handleFontSizeChange = async (e) => {
              const size = parseInt(e.target.value);
              setLocalFontSize(size);
              onFontSizeChange(size);
              await setFontSize(size);
          };
          
          const handleThemeUpdate = async (key, value) => {
              if (!appTheme) return;
              const newTheme = {
                  ...appTheme,
                  [themeMode]: {
                      ...appTheme[themeMode],
                      [key]: value
                  }
              };
              setLocalAppTheme(newTheme);
              await setAppTheme(newTheme);
              onThemeChange();
          };

          const handleVisibilityChange = async (key, val) => {
              if (key === 'showFavorites') setShowFavorites(val);
              if (key === 'showContent') setShowContent(val);
              await setSectionVisibility(key, val);
              onSettingsChange();
          };

          const handleCreateVault = () => {
              if (newVaultName.trim()) {
                  createVault(newVaultName.trim());
              }
          };
          
          const handleReset = () => {
              if (confirmReset) {
                  resetCurrentVault();
              } else {
                  setConfirmReset(true);
              }
          };

          const handleDelete = () => {
              if (confirmDelete) {
                  deleteCurrentVault();
              } else {
                  setConfirmDelete(true);
              }
          };

          if (!isOpen) return null;

          return (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
              <div className="w-full max-w-4xl h-[85vh] bg-background rounded-xl shadow-2xl border border-gray-200 dark:border-gray-800 flex flex-col">
                <div className="flex justify-between items-center p-6 pb-2">
                    <h2 className="text-xl font-bold">Settings</h2>
                    <button onClick={onClose} className="text-gray-500 hover:text-foreground">✕</button>
                </div>
                
                <div className="flex border-b border-gray-200 dark:border-gray-800 px-6">
                    <button
                        className={`py-2 px-4 text-sm font-medium border-b-2 transition-colors ${
                            activeTab === 'general' 
                            ? 'border-primary text-primary' 
                            : 'border-transparent text-gray-500 hover:text-foreground'
                        }`}
                        onClick={() => setActiveTab('general')}
                    >
                        General
                    </button>
                    <button
                        className={`py-2 px-4 text-sm font-medium border-b-2 transition-colors ${
                            activeTab === 'theme' 
                            ? 'border-primary text-primary' 
                            : 'border-transparent text-gray-500 hover:text-foreground'
                        }`}
                        onClick={() => setActiveTab('theme')}
                    >
                        Theme
                    </button>
                    <button
                        className={`py-2 px-4 text-sm font-medium border-b-2 transition-colors ${
                            activeTab === 'database' 
                            ? 'border-primary text-primary' 
                            : 'border-transparent text-gray-500 hover:text-foreground'
                        }`}
                        onClick={() => setActiveTab('database')}
                    >
                        Database
                    </button>
                </div>

                <div className="flex-1 overflow-y-auto p-6">
                    
                    {activeTab === 'general' && (
                        <div className="space-y-6">
                            <div className="border-b border-gray-100 dark:border-gray-800 pb-6">
                                <h3 className="text-sm font-semibold text-gray-500 uppercase tracking-wide mb-2">Interface Font Size</h3>
                                <div className="flex items-center gap-4">
                                    <span className="text-sm w-8">{localFontSize}px</span>
                                    <input 
                                        type="range" 
                                        min="12" 
                                        max="32" 
                                        step="1"
                                        value={localFontSize}
                                        onChange={handleFontSizeChange}
                                        className="flex-1 accent-primary"
                            />
                                </div>
                                <p className="text-xs text-gray-400 mt-2">Affects note lists. Central note is 150% of this size.</p>
                            </div>

                            <div className="border-b border-gray-100 dark:border-gray-800 pb-6">
                                <h3 className="text-sm font-semibold text-gray-500 uppercase tracking-wide mb-3">Section Visibility</h3>
                                <div className="flex flex-col gap-3">
                                    <label className="flex items-center gap-3 cursor-pointer">
                                        <input 
                                            type="checkbox" 
                                            className="w-4 h-4 rounded border-gray-300 text-primary focus:ring-primary"
                                            checked={showFavorites}
                                            onChange={(e) => handleVisibilityChange('showFavorites', e.target.checked)}
                                        />
                                        <span className="text-sm font-medium">Show Favorites Section</span>
                                    </label>
                                    <label className="flex items-center gap-3 cursor-pointer">
                                        <input 
                                            type="checkbox" 
                                            className="w-4 h-4 rounded border-gray-300 text-primary focus:ring-primary"
                                            checked={showContent}
                                            onChange={(e) => handleVisibilityChange('showContent', e.target.checked)}
                                        />
                                        <span className="text-sm font-medium">Show Content Section</span>
                                    </label>
                                </div>
                                 <p className="text-xs text-gray-400 mt-2">When hidden, the section above will expand to fill the vertical space.</p>
                            </div>

                            <div>
                                <h3 className="text-sm font-semibold text-gray-500 uppercase tracking-wide mb-2">Home Note</h3>
                                <div className="flex items-center justify-between bg-card p-3 rounded border border-gray-200 dark:border-gray-700 mb-2">
                                    <span className="font-medium truncate">{homeNoteTitle}</span>
                                </div>
                                
                                <button 
                                    onClick={setCenterAsHome}
                                    className="w-full py-2 px-4 bg-primary/10 text-primary rounded hover:bg-primary/20 text-sm font-medium mb-4"
                                >
                                    Set Current View as Home
                                </button>

                                <div className="relative">
                                    <input
                                        type="text"
                                        placeholder="Search note to set as Home..."
                                        className="w-full p-2 rounded border border-gray-300 dark:border-gray-700 bg-background focus:ring-2 focus:ring-primary outline-none"
                                        value={searchQuery}
                                        onChange={(e) => handleSearch(e.target.value)}
                                    />
                                    {searchResults.length > 0 && (
                                        <div className="absolute top-full left-0 right-0 bg-card border border-gray-200 dark:border-gray-700 shadow-lg rounded-b mt-1 z-50 max-h-48 overflow-y-auto">
                                            {searchResults.map(res => (
                                                <div 
                                                    key={res.id} 
                                                    className="p-2 hover:bg-primary/10 cursor-pointer text-sm"
                                                    onClick={() => setHome(res.id, res.title)}
                                                >
                                                    {res.title}
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {activeTab === 'theme' && appTheme && (
                        <div className="space-y-6">
                            <div className="flex justify-center p-1 bg-gray-100 dark:bg-gray-800 rounded-lg mb-6">
                                <button
                                    className={`flex-1 py-1 text-sm font-medium rounded-md transition-all ${
                                        themeMode === 'light' ? 'bg-white text-gray-900 shadow-sm' : 'text-gray-500 hover:text-gray-900 dark:hover:text-gray-300'
                                    }`}
                                    onClick={() => setThemeMode('light')}
                                >
                                    Light Mode
                                </button>
                                <button
                                    className={`flex-1 py-1 text-sm font-medium rounded-md transition-all ${
                                        themeMode === 'dark' ? 'bg-gray-600 text-white shadow-sm' : 'text-gray-500 hover:text-gray-900 dark:hover:text-gray-300'
                                    }`}
                                    onClick={() => setThemeMode('dark')}
                                >
                                    Dark Mode
                                </button>
                            </div>

                            <div className="space-y-4">
                                <div className="flex items-center justify-between">
                                    <div className="flex flex-col">
                                        <span className="font-medium text-sm">Background Color</span>
                                        <span className="text-xs text-gray-500">The gutters/canvas background</span>
                                    </div>
                                    <input 
                                        type="color" 
                                        value={appTheme[themeMode].background}
                                        onChange={e => handleThemeUpdate('background', e.target.value)}
                                        className="h-8 w-14 p-0 border-0 rounded cursor-pointer"
                                    />
                                </div>

                                <div className="flex items-center justify-between">
                                    <div className="flex flex-col">
                                        <span className="font-medium text-sm">Section Color</span>
                                        <span className="text-xs text-gray-500">Background for note containers</span>
                                    </div>
                                    <input 
                                        type="color" 
                                        value={appTheme[themeMode].section}
                                        onChange={e => handleThemeUpdate('section', e.target.value)}
                                        className="h-8 w-14 p-0 border-0 rounded cursor-pointer"
                                    />
                                </div>

                                <div className="flex items-center justify-between">
                                    <div className="flex flex-col">
                                        <span className="font-medium text-sm">Bars Background</span>
                                        <span className="text-xs text-gray-500">Top bar and status bar</span>
                                    </div>
                                    <input 
                                        type="color" 
                                        value={appTheme[themeMode].bars}
                                        onChange={e => handleThemeUpdate('bars', e.target.value)}
                                        className="h-8 w-14 p-0 border-0 rounded cursor-pointer"
                                    />
                                </div>

                                <div className="flex items-center justify-between">
                                    <div className="flex flex-col">
                                        <span className="font-medium text-sm">Accent Color</span>
                                        <span className="text-xs text-gray-500">Icons and active elements</span>
                                    </div>
                                    <input 
                                        type="color" 
                                        value={appTheme[themeMode].accent}
                                        onChange={e => handleThemeUpdate('accent', e.target.value)}
                                        className="h-8 w-14 p-0 border-0 rounded cursor-pointer"
                                    />
                                </div>
                            </div>
                        </div>
                    )}

                    {activeTab === 'database' && (
                        <div className="space-y-6">
                            <div>
                                <h3 className="text-sm font-semibold text-gray-500 uppercase tracking-wide mb-2">Current Database</h3>
                                <div className="bg-gray-100 dark:bg-gray-800 p-3 rounded mb-4 border border-gray-200 dark:border-gray-700">
                                    <div className="text-xs text-gray-500 mb-1">Active Vault</div>
                                    <div className="font-mono font-bold text-lg text-primary truncate">{currentVault}</div>
                                </div>
                            </div>

                            <div>
                                <h3 className="text-sm font-semibold text-gray-500 uppercase tracking-wide mb-2">New Vault</h3>
                                <div className="flex gap-2">
                                    <input 
                                        type="text" 
                                        placeholder="Vault Name..." 
                                        className="flex-1 p-2 rounded border border-gray-300 dark:border-gray-700 bg-background outline-none focus:ring-1 focus:ring-primary"
                                        value={newVaultName}
                                        onChange={e => setNewVaultName(e.target.value)}
                                        onKeyDown={e => e.key === 'Enter' && handleCreateVault()}
                                    />
                                    <button 
                                        onClick={handleCreateVault}
                                        disabled={!newVaultName.trim()}
                                        className="px-3 py-2 bg-primary text-primary-foreground rounded hover:opacity-90 disabled:opacity-50"
                                    >
                                        Create
                                    </button>
                                </div>
                            </div>

                            <div className="pt-4 border-t border-gray-200 dark:border-gray-700 space-y-4">
                                <h3 className="text-sm font-semibold text-gray-500 uppercase tracking-wide">Danger Zone</h3>
                                
                                <div>
                                    <button 
                                        onClick={handleReset}
                                        className={`w-full py-2 px-4 rounded text-sm font-medium transition-all ${
                                            confirmReset 
                                                ? 'bg-red-500 text-white hover:bg-red-600' 
                                                : 'bg-gray-200 dark:bg-gray-700 text-foreground hover:opacity-80'
                                        }`}
                                    >
                                        {confirmReset ? 'Confirm: Reset (Clear Data)' : 'Reset Current Vault'}
                                    </button>
                                    {confirmReset && <p className="text-xs text-red-500 mt-1 text-center">Warning: All notes in this vault will be lost.</p>}
                                </div>

                                <div>
                                    <button 
                                        onClick={handleDelete}
                                        className={`w-full py-2 px-4 rounded text-sm font-medium transition-all ${
                                            confirmDelete 
                                                ? 'bg-red-500 text-white hover:bg-red-600' 
                                                : 'bg-red-500/10 text-red-500 hover:bg-red-500/20'
                                        }`}
                                    >
                                        {confirmDelete ? 'Confirm: DELETE VAULT PERMANENTLY' : 'Delete Current Vault'}
                                    </button>
                                     {confirmDelete && <p className="text-xs text-red-500 mt-1 text-center">Warning: This vault and all its data will be destroyed.</p>}
                                </div>
                            </div>
                        </div>
                    )}
                </div>
                
                <div className="flex justify-end p-4 border-t border-gray-100 dark:border-gray-800">
                    <button onClick={onClose} className="px-4 py-2 rounded bg-primary text-primary-foreground hover:opacity-90">Done</button>
                </div>
              </div>
            </div>
          );
        };

        // --- 4. Mount ---

        const rootElement = document.getElementById('root');
        const root = ReactDOM.createRoot(rootElement);
        
        function App() {
          const [centralNoteId, setCentralNoteId] = useState(null);
          const [topology, setTopology] = useState({
            center: null,
            uppers: [],
            downers: [],
            lefters: [],
            righters: [],
          });
          const [favorites, setFavorites] = useState([]);
          const [isDarkMode, setIsDarkMode] = useState(true);
          const [fontSize, setFontSize] = useState(16);
          const [themeTick, setThemeTick] = useState(0);
          const [totalNoteCount, setTotalNoteCount] = useState(0);

          const [showFavorites, setShowFavorites] = useState(true);
          const [showContent, setShowContent] = useState(true);
          
          const [focusedSection, setFocusedSection] = useState('center');
          const [focusedIndex, setFocusedIndex] = useState(0);
          const [sectionIndices, setSectionIndices] = useState({ up: 0, down: 0, left: 0, right: 0, favs: 0 });

          const [selectedNoteIds, setSelectedNoteIds] = useState(new Set());
          const selectedNoteIdsRef = useRef(new Set());

          const [showMainMenu, setShowMainMenu] = useState(false);
          const [showFavDropdown, setShowFavDropdown] = useState(false);
          const [showVaultListInMenu, setShowVaultListInMenu] = useState(false);
          const [searchQuery, setSearchQuery] = useState('');
          const [searchResults, setSearchResults] = useState([]);
          const [activeSearchIndex, setActiveSearchIndex] = useState(0); 
          const [isSearchActive, setIsSearchActive] = useState(false);
          
          const [editorOpen, setEditorOpen] = useState(false);
          const [editorMode, setEditorMode] = useState('view');
          
          const [linkerOpen, setLinkerOpen] = useState(false);
          const [linkerType, setLinkerType] = useState('up');
          
          const [renameModalOpen, setRenameModalOpen] = useState(false);
          const [noteToRename, setNoteToRename] = useState(null);

          const [settingsOpen, setSettingsOpen] = useState(false);
          
          const [previewHtml, setPreviewHtml] = useState('');
          
          const searchInputRef = useRef(null);
          const searchResultsRef = useRef(null);
          const mainContainerRef = useRef(null);
          const contentPreviewRef = useRef(null);

          useEffect(() => {
            const init = async () => {
              const seededId = await seedDatabase();
              const lastId = await db.meta.get('currentCentralNoteId');
              setCentralNoteId(lastId ? lastId.value : seededId);
              
              const fs = await getFontSize();
              setFontSize(fs);

              const vis = await getSectionVisibility();
              setShowFavorites(vis.showFavorites);
              setShowContent(vis.showContent);

              refreshFavorites();
              updateTotalCount();

              setTimeout(() => {
                if (mainContainerRef.current) {
                    mainContainerRef.current.focus();
                }
              }, 100);

              document.title = `JaRoet PKM - ${getCurrentVaultName()}`;
            };
            init();
          }, []);

          const refreshSettings = async () => {
               const vis = await getSectionVisibility();
               setShowFavorites(vis.showFavorites);
               setShowContent(vis.showContent);
          };

          useEffect(() => {
            if (isDarkMode) {
              document.documentElement.classList.add('dark');
            } else {
              document.documentElement.classList.remove('dark');
            }
          }, [isDarkMode]);

          useEffect(() => {
              selectedNoteIdsRef.current = selectedNoteIds;
          }, [selectedNoteIds]);

          useEffect(() => {
            const applyTheme = async () => {
                const theme = await getAppTheme();
                const styleId = 'dynamic-theme-styles';
                let styleTag = document.getElementById(styleId);
                if (!styleTag) {
                  styleTag = document.createElement('style');
                  styleTag.id = styleId;
                  document.head.appendChild(styleTag);
                }
                styleTag.innerHTML = `
                  :root {
                    --theme-bg: ${theme.light.background};
                    --theme-section: ${theme.light.section};
                    --theme-bars: ${theme.light.bars};
                    --theme-accent: ${theme.light.accent};
                    --primary: ${theme.light.accent};
                  }
                  .dark {
                    --theme-bg: ${theme.dark.background};
                    --theme-section: ${theme.dark.section};
                    --theme-bars: ${theme.dark.bars};
                    --theme-accent: ${theme.dark.accent};
                    --primary: ${theme.dark.accent};
                  }
                `;
            };
            applyTheme();
          }, [themeTick]);

          useEffect(() => {
            if (centralNoteId) {
              loadTopology(centralNoteId);
              db.meta.put({ key: 'currentCentralNoteId', value: centralNoteId });
              setFocusedSection('center');
              setFocusedIndex(0);
              setSectionIndices({ up: 0, down: 0, left: 0, right: 0, favs: 0 });
              setSelectedNoteIds(new Set());
              updateTotalCount();
            }
          }, [centralNoteId]);

          useEffect(() => {
            if (focusedSection !== 'center' && focusedSection !== 'content') {
              setSectionIndices(prev => ({ ...prev, [focusedSection]: focusedIndex }));
            }
          }, [focusedIndex, focusedSection]);

          useEffect(() => {
            if (focusedSection === 'center' || focusedSection === 'content') return;
            const elementId = `note-${focusedSection}-${focusedIndex}`;
            const el = document.getElementById(elementId);
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
            }
          }, [focusedSection, focusedIndex]);

          useEffect(() => {
              if (focusedSection === 'content' && contentPreviewRef.current) {
                  contentPreviewRef.current.focus();
              }
          }, [focusedSection]);

          useEffect(() => {
            const runSearch = async () => {
                if (searchQuery.trim()) {
                    const results = await searchNotes(searchQuery);
                    setSearchResults(results);
                    setActiveSearchIndex(0);
                } else {
                    setSearchResults([]);
                    setActiveSearchIndex(0);
                }
            };
            const debounce = setTimeout(runSearch, 200);
            return () => clearTimeout(debounce);
          }, [searchQuery]);

          useEffect(() => {
              if (isSearchActive && searchResultsRef.current) {
                  const activeEl = searchResultsRef.current.children[activeSearchIndex];
                  if (activeEl) {
                      activeEl.scrollIntoView({ block: 'nearest' });
                  }
              }
          }, [activeSearchIndex, isSearchActive]);


          const loadTopology = async (id) => {
            const data = await getTopology(id);
            setTopology(data);
          };

          const refreshFavorites = async () => {
            const favs = await getFavorites();
            setFavorites(favs);
          };
          
          const updateTotalCount = async () => {
              const count = await getNoteCount();
              setTotalNoteCount(count);
          };

          const getSortedNotes = useCallback((section) => {
              let notes = [];
              if (section === 'center') return topology.center ? [topology.center] : [];
              if (section === 'up') notes = topology.uppers;
              if (section === 'down') notes = topology.downers;
              if (section === 'left') notes = topology.lefters;
              if (section === 'right') notes = topology.righters;
              if (section === 'favs') notes = favorites;
              
              return [...notes].sort((a, b) => a.title.localeCompare(b.title));
          }, [topology, favorites]);

          const getFocusedNote = useCallback(() => {
            if (focusedSection === 'content') return topology.center;
            if (focusedSection === 'center') return topology.center;
            const notes = getSortedNotes(focusedSection);
            return notes[focusedIndex] || null;
          }, [focusedSection, focusedIndex, getSortedNotes, topology]);

          useEffect(() => {
              const updatePreview = async () => {
                  const target = getFocusedNote() || topology.center;
                  if (target && target.content) {
                      try {
                        const html = await marked.parse(target.content, { breaks: true, gfm: true });
                        setPreviewHtml(html);
                      } catch {
                        setPreviewHtml('<p class="text-red-500">Error rendering markdown</p>');
                      }
                  } else {
                      setPreviewHtml('<p class="text-gray-500 italic">No content</p>');
                  }
              };
              const t = setTimeout(updatePreview, 100);
              return () => clearTimeout(t);
          }, [focusedSection, focusedIndex, topology, favorites]);


          useEffect(() => {
            // Safety check if hidden sections are focused
            if (focusedSection === 'favs' && !showFavorites) {
                setFocusedSection('left');
                setFocusedIndex(0);
                return;
            }
            if (focusedSection === 'content' && !showContent) {
                setFocusedSection('right');
                setFocusedIndex(0);
                return;
            }

            if (focusedSection === 'center' || focusedSection === 'content') return;

            const notes = getSortedNotes(focusedSection);
            if (notes.length === 0) {
                setFocusedSection('center');
                setFocusedIndex(0);
                return;
            }
            if (focusedIndex >= notes.length) {
                setFocusedIndex(notes.length - 1);
            }
          }, [topology, favorites, focusedSection, focusedIndex, getSortedNotes, showFavorites, showContent]);


          const handleFavoriteToggle = async () => {
            const note = getFocusedNote();
            if (note) {
              await toggleFavorite(note.id);
              loadTopology(centralNoteId);
              refreshFavorites();
            }
          };

          const handleJournal = async () => {
              const todayId = await goToToday();
              setCentralNoteId(todayId);
          };

          const handleRename = async (newTitle) => {
            if (noteToRename) {
              await updateNote(noteToRename.id, { title: newTitle });
              setNoteToRename(null);
              loadTopology(centralNoteId);
              refreshFavorites();
            }
          };

          const handleStartRename = () => {
            const note = getFocusedNote();
            if (note) {
                setNoteToRename(note);
                setRenameModalOpen(true);
            }
          };

          const handleOpenEditor = (mode) => {
            const note = getFocusedNote();
            if (note) {
                setEditorMode(mode);
                setEditorOpen(true);
            }
          };

          const goHome = useCallback(async () => {
            const homeId = await getHomeNoteId();
            if (homeId) {
                const exists = await getNote(homeId);
                if (exists) {
                    setCentralNoteId(homeId);
                } else {
                    const all = await getAllNotes();
                    if (all.length > 0) {
                        setCentralNoteId(all[0].id);
                    } else {
                        const newId = await seedDatabase();
                        if (newId) setCentralNoteId(newId);
                    }
                }
            } else {
                setSettingsOpen(true);
            }
          }, []);

          const performDelete = useCallback(async (note) => {
                await deleteNote(note.id);
                if (note.id === centralNoteId) {
                    goHome(); 
                } else {
                    if (centralNoteId) loadTopology(centralNoteId);
                }
                refreshFavorites();
                updateTotalCount();
          }, [centralNoteId, goHome]);

          const performBulkDelete = useCallback(async (ids) => {
              let centerDeleted = false;
              for (const id of ids) {
                  await deleteNote(id);
                  if (id === centralNoteId) centerDeleted = true;
              }

              if (centerDeleted) {
                  await goHome();
              } else {
                  if (centralNoteId) await loadTopology(centralNoteId);
              }
              refreshFavorites();
              updateTotalCount();
              setSelectedNoteIds(new Set()); 
          }, [centralNoteId, goHome]);

          const handleDeleteAction = useCallback(async (e) => {
            if (e) e.preventDefault();
            
            const selectedIds = Array.from(selectedNoteIdsRef.current);
            if (selectedIds.length > 0) {
                if(confirm(`Are you sure you want to delete ${selectedIds.length} selected notes?`)) {
                    await performBulkDelete(selectedIds);
                }
            } else {
                const note = getFocusedNote();
                if (note) {
                    await performDelete(note);
                }
            }
          }, [selectedNoteIds, getFocusedNote, performBulkDelete, performDelete]);

          const getSelectedOrFocusedNotes = () => {
              if (selectedNoteIdsRef.current.size > 0) {
                  return Array.from(selectedNoteIdsRef.current);
              }
              const active = getFocusedNote();
              return active ? [active.id] : [];
          };

          const changeRelationship = async (type) => {
              if (!centralNoteId) return;

              const targetIds = getSelectedOrFocusedNotes();
              if (targetIds.length === 0) return;

              const validTargets = targetIds.filter(id => id !== centralNoteId);
              if (validTargets.length === 0) return;

              const cleanRelationships = async (centerId, targetId) => {
                const center = await getNote(centerId);
                const target = await getNote(targetId);
                if (!center || !target) return;

                if (center.linksTo.includes(targetId)) {
                    await updateNote(centerId, { linksTo: center.linksTo.filter(id => id !== targetId) });
                }
                if (target.linksTo.includes(centerId)) {
                    await updateNote(targetId, { linksTo: target.linksTo.filter(id => id !== centerId) });
                }
                if (center.relatedTo.includes(targetId)) {
                    await updateNote(centerId, { relatedTo: center.relatedTo.filter(id => id !== targetId) });
                }
                if (target.relatedTo.includes(centerId)) {
                    await updateNote(targetId, { relatedTo: target.relatedTo.filter(id => id !== targetId) });
                }
              };

              for (const id of validTargets) {
                  await cleanRelationships(centralNoteId, id);

                  if (type === 'up') {
                    const target = await getNote(id);
                    if (target) {
                        await updateNote(id, { linksTo: [...target.linksTo, centralNoteId] });
                    }
                  } else if (type === 'down') {
                    const center = await getNote(centralNoteId);
                    if (center) {
                        await updateNote(centralNoteId, { linksTo: [...center.linksTo, id] });
                    }
                  } else if (type === 'left') {
                    const center = await getNote(centralNoteId);
                    if (center) await updateNote(centralNoteId, { relatedTo: [...center.relatedTo, id] });
                    
                    const target = await getNote(id);
                    if (target) await updateNote(id, { relatedTo: [...target.relatedTo, centralNoteId] });
                  }
              }

              loadTopology(centralNoteId);
              setSelectedNoteIds(new Set());
          };

          const handleToggleSelection = (noteId) => {
              if (noteId === centralNoteId) return; 
              setSelectedNoteIds(prev => {
                  const next = new Set(prev);
                  if (next.has(noteId)) {
                      next.delete(noteId);
                  } else {
                      next.add(noteId);
                  }
                  return next;
              });
          };

          const handleLinkerSelect = async (targetId, newTitle) => {
            if (!centralNoteId) return;

            const cleanRelationships = async (centerId, targetId) => {
                const center = await getNote(centerId);
                const target = await getNote(targetId);
                if (!center || !target) return;
                if (center.linksTo.includes(targetId)) {
                    await updateNote(centerId, { linksTo: center.linksTo.filter(id => id !== targetId) });
                }
                if (target.linksTo.includes(centerId)) {
                    await updateNote(targetId, { linksTo: target.linksTo.filter(id => id !== centerId) });
                }
                if (center.relatedTo.includes(targetId)) {
                    await updateNote(centerId, { relatedTo: center.relatedTo.filter(id => id !== targetId) });
                }
                if (target.relatedTo.includes(centerId)) {
                    await updateNote(targetId, { relatedTo: target.relatedTo.filter(id => id !== targetId) });
                }
            };
            
            const linkToTarget = async (id) => {
                await cleanRelationships(centralNoteId, id);
                if (linkerType === 'up') {
                    const target = await getNote(id);
                    if (target) await updateNote(id, { linksTo: [...target.linksTo, centralNoteId] });
                } else if (linkerType === 'down') {
                    const center = await getNote(centralNoteId);
                    if (center) await updateNote(centralNoteId, { linksTo: [...center.linksTo, id] });
                } else if (linkerType === 'left') {
                    const center = await getNote(centralNoteId);
                    if (center) await updateNote(centralNoteId, { relatedTo: [...center.relatedTo, id] });
                    const target = await getNote(id);
                    if (target) await updateNote(id, { relatedTo: [...target.relatedTo, centralNoteId] });
                }
            };

            if (!targetId && newTitle) {
                if (newTitle.includes(';')) {
                    const titles = newTitle.split(';').map(t => t.trim()).filter(t => t.length > 0);
                    for (const title of titles) {
                        const newNote = await createNote(title);
                        await linkToTarget(newNote.id);
                    }
                } else {
                    const newNote = await createNote(newTitle);
                    await linkToTarget(newNote.id);
                }
            } else if (targetId) {
                await linkToTarget(targetId);
            }

            loadTopology(centralNoteId);
            updateTotalCount();
          };

          const handleSearchSelect = (id) => {
            setCentralNoteId(id);
            setIsSearchActive(false);
            setSearchQuery('');
          };

          const exportData = async () => {
            const notes = await getAllNotes();
            const blob = new Blob([JSON.stringify(notes, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const now = new Date();
            const dateStr = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}`;
            a.download = `JaRoetPKM_${getCurrentVaultName()}_${dateStr}.json`;
            a.click();
            URL.revokeObjectURL(url);
            setShowMainMenu(false);
          };

          const importData = () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.style.display = 'none';
            document.body.appendChild(input);

            input.onchange = (e) => {
              const file = (e.target).files?.[0];
              if (file) {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const text = event.target?.result;
                        if (!text) throw new Error("Empty file");
                        const notes = JSON.parse(text);
                        await importNotes(notes);
                        document.body.removeChild(input);
                        setTimeout(() => {
                            window.location.reload();
                        }, 500);
                    } catch (err) {
                        console.error(err);
                        alert('Error importing file.');
                        if (document.body.contains(input)) document.body.removeChild(input);
                    }
                };
                reader.readAsText(file);
              } else {
                if (document.body.contains(input)) document.body.removeChild(input);
              }
            };
            input.click();
            setShowMainMenu(false);
          };

          const handleGlobalKeyDown = useCallback(async (e) => {
            if (e.key === 'Escape') {
                let closed = false;
                if (showFavDropdown) {
                    setShowFavDropdown(false);
                    closed = true;
                }
                if (showMainMenu) {
                    setShowMainMenu(false);
                    closed = true;
                }
                if (selectedNoteIdsRef.current.size > 0) {
                    setSelectedNoteIds(new Set());
                    closed = true;
                }
                if (closed) {
                    if (selectedNoteIdsRef.current.size === 0) {
                        setFocusedSection('center');
                        setFocusedIndex(0);
                    }
                    e.preventDefault();
                    return;
                }
            }

            if (renameModalOpen || isSearchActive || editorOpen || linkerOpen || settingsOpen) return;

            if (e.key === '/') {
              e.preventDefault();
              setIsSearchActive(true);
              setTimeout(() => searchInputRef.current?.focus(), 50);
              return;
            }
            
            // Journal Mode (Ctrl+J)
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'j') {
                e.preventDefault();
                handleJournal();
                return;
            }

            if (e.key === 'x') {
                e.preventDefault();
                const note = getFocusedNote();
                if (note && note.id !== centralNoteId) {
                    handleToggleSelection(note.id);
                    // Automatically move to the next note for rapid selection
                    const notes = getSortedNotes(focusedSection);
                    if (focusedIndex < notes.length - 1) {
                        setFocusedIndex(prev => prev + 1);
                    }
                }
                return;
            }

            if (e.ctrlKey && e.key === 'Backspace') {
                e.preventDefault();
                await handleDeleteAction();
                return;
            }

            if (e.key === 'Backspace') {
              e.preventDefault();
              if (selectedNoteIdsRef.current.size > 0) {
                  await changeRelationship('unlink');
                  return;
              }
              const note = getFocusedNote();
              if (note && centralNoteId && focusedSection !== 'center' && focusedSection !== 'right' && focusedSection !== 'favs' && focusedSection !== 'content') {
                await changeRelationship('unlink');
                loadTopology(centralNoteId);
              }
              return;
            }

            if (e.ctrlKey) {
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    if (selectedNoteIdsRef.current.size > 0) {
                        await changeRelationship('up');
                    } else {
                        setLinkerType('up');
                        setLinkerOpen(true);
                    }
                    return;
                }
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    if (selectedNoteIdsRef.current.size > 0) {
                        await changeRelationship('down');
                    } else {
                        setLinkerType('down');
                        setLinkerOpen(true);
                    }
                    return;
                }
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (selectedNoteIdsRef.current.size > 0) {
                        await changeRelationship('left');
                    } else {
                        setLinkerType('left');
                        setLinkerOpen(true);
                    }
                    return;
                }
            }

            if (e.key === 'F2') {
                e.preventDefault();
                handleStartRename();
                return;
            }

            // Priority Fix: Check Shift+Enter (Open Editor) BEFORE checking plain Enter (Focus Center)
            if (e.shiftKey && e.key === 'Enter') {
                e.preventDefault();
                handleOpenEditor('view');
                return;
            }

            // Ctrl+Enter: Open Editor in Edit Mode
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleOpenEditor('edit');
                return;
            }

            // NEW LOGIC: Enter = Focus Center (Recenter Focus)
            if (e.key === 'Enter') { 
                e.preventDefault();
                setFocusedSection('center');
                return;
            }

            // NEW LOGIC: Space = Open Note (Navigate Into)
            if (e.key === ' ') {
                e.preventDefault();
                const note = getFocusedNote();
                if (note && note.id !== centralNoteId) {
                    setCentralNoteId(note.id);
                }
                return;
            }

            const getItemsPerColumn = (sectionId) => {
                const container = document.getElementById(sectionId);
                if (!container) return 1;
                const cards = Array.from(container.children).filter(c => c.id.startsWith('note-'));
                if (cards.length < 2) return 1;
                const firstLeft = (cards[0]).offsetLeft;
                for (let i = 1; i < cards.length; i++) {
                    const currentLeft = (cards[i]).offsetLeft;
                    if (currentLeft > firstLeft + 20) {
                        return i;
                    }
                }
                return cards.length;
            };

            if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (e.shiftKey && ['up', 'down', 'left', 'right', 'favs'].includes(focusedSection)) {
                     const notes = getSortedNotes(focusedSection);
                     if (notes.length === 0) return;
                     if (selectedNoteIds.size === 0) {
                         const current = notes[focusedIndex];
                         if (current) handleToggleSelection(current.id);
                     }
                     if (focusedIndex > 0) {
                         const newIndex = focusedIndex - 1;
                         setFocusedIndex(newIndex);
                         const target = notes[newIndex];
                         if (target) {
                             setSelectedNoteIds(prev => {
                                 const next = new Set(prev);
                                 next.add(target.id); 
                                 return next;
                             });
                         }
                     }
                     return;
                }

                if (focusedSection === 'content') {
                     setFocusedSection('right');
                     setFocusedIndex(Math.min(sectionIndices.right, topology.righters.length - 1));
                     return;
                }

                if (focusedSection === 'center') {
                    if (topology.uppers.length > 0) {
                        setFocusedSection('up');
                        const target = Math.min(sectionIndices.up, topology.uppers.length - 1);
                        setFocusedIndex(target);
                    }
                } else if (focusedSection === 'down') {
                     if (focusedIndex === 0) {
                        setFocusedSection('center');
                     } else {
                         setFocusedIndex(prev => Math.max(0, prev - 1));
                     }
                } else if (focusedSection === 'favs') {
                    if (focusedIndex === 0) {
                        setFocusedSection('left');
                        const target = Math.min(sectionIndices.left, topology.lefters.length - 1);
                        setFocusedIndex(target);
                    } else {
                        setFocusedIndex(prev => Math.max(0, prev - 1));
                    }
                } else {
                    setFocusedIndex(prev => Math.max(0, prev - 1));
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (e.shiftKey && ['up', 'down', 'left', 'right', 'favs'].includes(focusedSection)) {
                     const notes = getSortedNotes(focusedSection);
                     if (notes.length === 0) return;
                     if (selectedNoteIds.size === 0) {
                         const current = notes[focusedIndex];
                         if (current) handleToggleSelection(current.id);
                     }
                     if (focusedIndex < notes.length - 1) {
                         const newIndex = focusedIndex + 1;
                         setFocusedIndex(newIndex);
                         const target = notes[newIndex];
                         if (target) {
                             setSelectedNoteIds(prev => {
                                 const next = new Set(prev);
                                 next.add(target.id);
                                 return next;
                             });
                         }
                     }
                     return;
                }
                if (focusedSection === 'content') return;
                if (focusedSection === 'center') {
                     if (topology.downers.length > 0) {
                setFocusedSection('down');
                const target = Math.min(sectionIndices.down, topology.downers.length - 1);
                setFocusedIndex(target);
             }
        } else if (focusedSection === 'up') {
            const arr = topology.uppers;
            if (focusedIndex === arr.length - 1) {
                setFocusedSection('center');
            } else {
                 setFocusedIndex(prev => Math.min(arr.length - 1, prev + 1));
            }
        } else if (focusedSection === 'left') {
             const arr = topology.lefters;
             if (focusedIndex === arr.length - 1) {
                 if (showFavorites && favorites.length > 0) {
                    setFocusedSection('favs');
                    setFocusedIndex(Math.min(sectionIndices.favs, favorites.length - 1));
                 }
             } else {
                 setFocusedIndex(prev => Math.min(arr.length - 1, prev + 1));
             }
        } else if (focusedSection === 'right') {
             const arr = topology.righters;
             if (focusedIndex === arr.length - 1) {
                 if (showContent) {
                     setFocusedSection('content');
                 }
             } else {
                 setFocusedIndex(prev => Math.min(arr.length - 1, prev + 1));
             }
        } else {
            const arr = getSortedNotes(focusedSection);
            setFocusedIndex(prev => Math.min(arr.length - 1, prev + 1));
        }
    } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        
        // Handle Intra-Section Column Navigation (Left)
        if (['up', 'down', 'left', 'right', 'favs'].includes(focusedSection)) {
             const containerId = `container-${focusedSection}`;
             const itemsPerCol = getItemsPerColumn(containerId);
             const newIndex = focusedIndex - itemsPerCol;
             if (newIndex >= 0) {
                 setFocusedIndex(newIndex);
                 return; // Stay in section, just moved column left
             }
             // If < 0, fall through to section switch logic
        }

        if (focusedSection === 'content') {
             setFocusedSection('down');
             setFocusedIndex(Math.min(sectionIndices.down, topology.downers.length - 1));
             return;
        }
        if (focusedSection === 'center') {
            if (topology.lefters.length > 0) {
                setFocusedSection('left');
                const target = Math.min(sectionIndices.left, topology.lefters.length - 1);
                setFocusedIndex(target);
            } else if (showFavorites && favorites.length > 0) {
                 setFocusedSection('favs');
                 const target = Math.min(sectionIndices.favs, favorites.length - 1);
                 setFocusedIndex(target);
            }
        } else if (focusedSection === 'right') {
             setFocusedSection('up');
             setFocusedIndex(Math.min(sectionIndices.up, topology.uppers.length - 1));
        } else if (focusedSection === 'down') {
             if (showFavorites && favorites.length > 0) {
                 setFocusedSection('favs');
                 setFocusedIndex(Math.min(sectionIndices.favs, favorites.length - 1));
             } else {
                 setFocusedSection('left');
                 setFocusedIndex(Math.min(sectionIndices.left, topology.lefters.length - 1));
             }
        } else if (focusedSection === 'up') {
            setFocusedSection('left');
            setFocusedIndex(Math.min(sectionIndices.left, topology.lefters.length - 1));
        }
    } else if (e.key === 'ArrowRight') {
        e.preventDefault();

        // Handle Intra-Section Column Navigation (Right)
        if (['up', 'down', 'left', 'right', 'favs'].includes(focusedSection)) {
             const containerId = `container-${focusedSection}`;
             const itemsPerCol = getItemsPerColumn(containerId);
             const notes = getSortedNotes(focusedSection);
             const newIndex = focusedIndex + itemsPerCol;
             
             if (newIndex < notes.length) {
                 setFocusedIndex(newIndex);
                 return; // Stay in section, just moved column right
             }
             // If >= length, fall through to section switch logic
        }

        if (focusedSection === 'content') return;
        if (focusedSection === 'center') {
            if (topology.righters.length > 0) {
                setFocusedSection('right');
                const target = Math.min(sectionIndices.right, topology.righters.length - 1);
                setFocusedIndex(target);
            } else {
                setFocusedSection('content');
            }
        } else if (focusedSection === 'left') {
            setFocusedSection('up'); 
            setFocusedIndex(Math.min(sectionIndices.up, topology.uppers.length - 1));
        } else if (focusedSection === 'favs') {
            setFocusedSection('down'); 
            setFocusedIndex(Math.min(sectionIndices.down, topology.downers.length - 1));
        } else if (focusedSection === 'up') {
             setFocusedSection('right');
             setFocusedIndex(Math.min(sectionIndices.right, topology.righters.length - 1));
        } else if (focusedSection === 'down') {
             if (showContent) {
                setFocusedSection('content');
             } else if (topology.righters.length > 0) {
                setFocusedSection('right');
                setFocusedIndex(Math.min(sectionIndices.right, topology.righters.length - 1));
             }
        } 
    }

  }, [focusedSection, focusedIndex, topology, favorites, centralNoteId, renameModalOpen, isSearchActive, editorOpen, linkerOpen, settingsOpen, fontSize, sectionIndices, getFocusedNote, getSortedNotes, showFavDropdown, showMainMenu, selectedNoteIds, showFavorites, showContent, handleDeleteAction]);

          useEffect(() => {
            window.addEventListener('keydown', handleGlobalKeyDown);
            return () => window.removeEventListener('keydown', handleGlobalKeyDown);
          }, [handleGlobalKeyDown]);

          const renderSection = (notes, section, containerClasses, itemClasses, containerId) => {
            const sortedNotes = [...notes].sort((a, b) => a.title.localeCompare(b.title));
            return (
                <div id={containerId} className={containerClasses}>
                    {sortedNotes.map((note, idx) => (
                        <NoteCard
                            key={note.id}
                            id={`note-${section}-${idx}`}
                            note={note}
                            fontSize={fontSize}
                            isFocused={focusedSection === section && focusedIndex === idx}
                            isSelected={selectedNoteIds.has(note.id)}
                            onClick={(e) => {
                                if (e.ctrlKey) {
                                    handleToggleSelection(note.id);
                                } else {
                                    if (note.id !== centralNoteId) setCentralNoteId(note.id);
                                }
                            }}
                            className={itemClasses}
                        />
                    ))}
                </div>
            );
          };
          
          const labelStyle = "absolute -top-[5px] left-6 px-3 py-0.5 font-bold tracking-wider bg-[var(--theme-section)] text-[color-mix(in_srgb,var(--theme-accent)_50%,transparent)] select-none z-20 pointer-events-none rounded-full border border-black/10 dark:border-white/10";
          const uiFontSize = Math.max(14, fontSize - 4);
          const activeNote = getFocusedNote();
          const activeNoteHasContent = activeNote?.content && activeNote.content.trim().length > 0;
          const hasSelection = selectedNoteIds.size > 0;
          const linkToolActive = hasSelection || (focusedSection !== 'center' && focusedSection !== 'content' && focusedSection !== 'right' && focusedSection !== 'favs');

          return (
            <div className="flex h-screen w-screen overflow-hidden bg-background text-foreground font-sans">
              
              <div className="flex-1 flex flex-col h-full min-w-0">
                
                {/* Top Bar - Compacted */}
                <div 
                    style={{ fontSize: `${uiFontSize}px` }} 
                    className="h-12 flex-shrink-0 flex items-center px-2 gap-1 z-40 shadow-md relative bg-[var(--theme-bars)] text-foreground transition-colors duration-300"
                >
                    
                    {/* Left Group: Menu, Home, Favorites List */}
                    <div className="flex items-center gap-1">
                        
                        {/* Main Menu (Hamburger) */}
                        <div className="relative">
                            <button 
                                onClick={() => setShowMainMenu(!showMainMenu)} 
                                title="Main Menu"
                                className="p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors"
                                style={{ color: 'var(--theme-accent)' }}
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
                            </button>
                            {showMainMenu && (
                                <div className="absolute top-full left-0 mt-2 w-64 bg-card text-foreground border border-gray-200 dark:border-gray-700 shadow-xl rounded-md z-50 flex flex-col py-2">
                                     
                                     {/* Vault Switcher Accordion */}
                                     <div className="border-b border-gray-100 dark:border-gray-800 mb-1 pb-1">
                                        <button 
                                            onClick={() => setShowVaultListInMenu(!showVaultListInMenu)}
                                            className="w-full px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-800 flex items-center justify-between gap-3 text-sm text-foreground"
                                        >
                                            <div className="flex items-center gap-3">
                                                <svg className="text-primary" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path></svg>
                                                <span>Vault: <span className="font-bold">{getCurrentVaultName()}</span></span>
                                            </div>
                                            <span className={`transform transition-transform ${showVaultListInMenu ? 'rotate-180' : ''}`}>▼</span>
                                        </button>
                                        {showVaultListInMenu && (
                                            <div className="bg-gray-50 dark:bg-zinc-900 border-y border-gray-100 dark:border-gray-800">
                                                {getVaultList().map(v => (
                                                    <div 
                                                        key={v}
                                                        className={`px-8 py-2 hover:bg-gray-200 dark:hover:bg-gray-800 cursor-pointer text-sm flex justify-between items-center ${
                                                            v === getCurrentVaultName() ? 'text-primary font-bold' : 'text-gray-500'
                                                        }`}
                                                        onClick={() => {
                                                            switchVault(v);
                                                            setShowMainMenu(false);
                                                        }}
                                                    >
                                                        <span className="truncate">{v}</span>
                                                        {v === getCurrentVaultName() && <span>•</span>}
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                     </div>

                                     {/* Theme Switcher */}
                                     <button 
                                        onClick={() => { setIsDarkMode(!isDarkMode); setShowMainMenu(false); }}
                                        className="px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-800 flex items-center gap-3 text-sm text-foreground"
                                     >
                                        <span className="w-5 flex justify-center text-primary">
                                            {isDarkMode ? (
                                                // Sun Icon for "Switch to Light"
                                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                                            ) : (
                                                // Moon Icon for "Switch to Dark"
                                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                                            )}
                                        </span>
                                        <span>Switch Theme</span>
                                     </button>

                                     {/* Settings */}
                                     <button 
                                        onClick={() => { setSettingsOpen(true); setShowMainMenu(false); }}
                                        className="px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-800 flex items-center gap-3 text-sm text-foreground"
                                     >
                                        <svg className="text-primary" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                                        <span>Settings</span>
                             </button>

                             {/* Export */}
                             <button 
                                onClick={() => { exportData(); setShowMainMenu(false); }}
                                className="px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-800 flex items-center gap-3 text-sm text-foreground"
                             >
                                <svg className="text-primary" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2 2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                                <span>Export Data</span>
                             </button>

                             {/* Import */}
                             <button 
                                onClick={() => { importData(); setShowMainMenu(false); }}
                                className="px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-800 flex items-center gap-3 text-sm text-foreground"
                             >
                                <svg className="text-primary" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                                <span>Import Data</span>
                             </button>
                        </div>
                    )}
                </div>

                <button 
                    onClick={goHome} 
                    title="Go Home" 
                    className="p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors"
                    style={{ color: 'var(--theme-accent)' }}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>
                </button>

                <button 
                    onClick={handleJournal} 
                    title="Go to Today's Journal (Ctrl+J)" 
                    className="p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors"
                    style={{ color: 'var(--theme-accent)' }}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
                </button>

                 {/* Favorites Dropdown */}
                 <div className="relative">
                    <button 
                        title="Favorites List"
                        onClick={() => setShowFavDropdown(!showFavDropdown)} 
                        className="p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors"
                        style={{ color: 'var(--theme-accent)' }}
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                            <g transform="translate(-1, 7) scale(0.4)">
                                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                            </g>
                            <g transform="translate(7, 7) scale(0.4)">
                                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                            </g>
                            <g transform="translate(15, 7) scale(0.4)">
                                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                            </g>
                        </svg>
                    </button>
                    {showFavDropdown && (
                        <div className="absolute top-full left-0 mt-2 w-64 bg-card text-foreground border border-gray-200 dark:border-gray-700 shadow-xl rounded-md z-50 max-h-80 overflow-y-auto">
                            <div className="p-2 font-bold text-xs uppercase text-gray-500 border-b dark:border-gray-700">Favorites</div>
                            {favorites.length === 0 && <div className="p-3 text-sm text-gray-500 italic text-center">No favorites yet</div>}
                            {favorites.map(fav => (
                                <div 
                                    key={fav.id}
                                    className="px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-800 cursor-pointer text-sm truncate"
                                    onClick={() => {
                                        setCentralNoteId(fav.id);
                                        setShowFavDropdown(false);
                                    }}
                                >
                                    {fav.title}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            </div>

            {/* Separator 1 */}
            <div className="h-6 w-px bg-current opacity-20 mx-0.5"></div>

            {/* Center Group: Note Actions */}
             <div className="flex items-center gap-1">
                <button 
                    title="Toggle Favorite (Current Note)"
                    onClick={handleFavoriteToggle} 
                    className={`p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors ${
                        activeNote?.isFavorite 
                            ? '' 
                            : 'text-gray-400'
                    }`}
                    style={activeNote?.isFavorite ? { color: 'var(--theme-accent)' } : {}}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill={activeNote?.isFavorite ? "currentColor" : "none"} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>
                </button>
                <button 
                    onClick={() => handleOpenEditor('view')} 
                    title="View Content (Shift+Enter)" 
                    className={`p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors ${
                        activeNoteHasContent 
                            ? '' 
                            : 'text-gray-400'
                    }`}
                    style={activeNoteHasContent ? { color: 'var(--theme-accent)' } : {}}
                >
                     <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill={activeNoteHasContent ? "currentColor" : "none"} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
                </button>
                <button 
                    onClick={handleStartRename} 
                    title="Rename Note (F2)" 
                    className="p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors"
                    style={{ color: 'var(--theme-accent)' }}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                </button>
                <button 
                    type="button" 
                    onClick={handleDeleteAction} 
                    title="Delete Note (Ctrl+Backspace)" 
                    className="p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors"
                    style={{ color: 'var(--theme-accent)' }}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                </button>
            </div>

            {/* Separator 2 */}
            <div className="h-6 w-px bg-current opacity-20 mx-0.5"></div>

             {/* Linking Tools */}
             <div className="flex items-center gap-1">
                <button 
                    onClick={() => changeRelationship('unlink')}
                    disabled={!linkToolActive}
                    title="Unlink Selected/Focused Note (Backspace)" 
                    className={`p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors ${!linkToolActive ? 'opacity-30 cursor-not-allowed' : ''}`}
                    style={{ color: 'var(--theme-accent)' }}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>
                </button>
                <button 
                    onClick={() => changeRelationship('left')}
                    disabled={!linkToolActive}
                    title="Link as Related (Ctrl+Left)" 
                    className={`p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors ${!linkToolActive ? 'opacity-30 cursor-not-allowed' : ''}`}
                    style={{ color: 'var(--theme-accent)' }}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
                </button>
                <button 
                    onClick={() => changeRelationship('up')}
                    disabled={!linkToolActive}
                    title="Link as Parent (Ctrl+Up)" 
                    className={`p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors ${!linkToolActive ? 'opacity-30 cursor-not-allowed' : ''}`}
                    style={{ color: 'var(--theme-accent)' }}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg>
                </button>
                <button 
                    onClick={() => changeRelationship('down')}
                    disabled={!linkToolActive}
                    title="Link as Child (Ctrl+Down)" 
                    className={`p-1.5 rounded hover:bg-black/10 dark:hover:bg-white/10 transition-colors ${!linkToolActive ? 'opacity-30 cursor-not-allowed' : ''}`}
                    style={{ color: 'var(--theme-accent)' }}
                >
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>
                </button>
             </div>

             {/* Separator 3 */}
             <div className="h-6 w-px bg-current opacity-20 mx-0.5"></div>

            {/* Right: Search (Fill) */}
            <div className="relative flex-1">
                <input 
                    ref={searchInputRef}
                    type="text" 
                    placeholder="Search (Press /)" 
                    className="w-full bg-black/5 dark:bg-black/20 text-foreground placeholder-gray-500 dark:placeholder-white/40 rounded-md px-3 py-1.5 outline-none transition-all border border-transparent focus:bg-black/10 dark:focus:bg-black/30"
                    style={{ fontSize: 'inherit', borderColor: 'var(--theme-accent)' }}
                    value={searchQuery}
                    onChange={e => setSearchQuery(e.target.value)}
                    onFocus={() => setIsSearchActive(true)}
                    onBlur={() => setTimeout(() => setIsSearchActive(false), 200)}
                    onKeyDown={(e) => {
                        if (e.key === 'Escape') {
                            setIsSearchActive(false);
                            searchInputRef.current?.blur();
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            setActiveSearchIndex(prev => (prev + 1) % searchResults.length);
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            setActiveSearchIndex(prev => (prev - 1 + searchResults.length) % searchResults.length);
                        } else if (e.key === 'Enter') {
                            e.preventDefault();
                            e.stopPropagation(); // Stop global handlers
                            // Fix: Directly use index instead of complex logic
                            const selected = searchResults[activeSearchIndex];
                            if (selected) {
                                handleSearchSelect(selected.id);
                                searchInputRef.current?.blur();
                            }
                        }
                    }}
                />
                {isSearchActive && searchResults.length > 0 && (
                    <div ref={searchResultsRef} className="absolute top-full left-0 right-0 bg-card text-foreground border border-gray-200 dark:border-gray-700 shadow-xl rounded-b-md mt-1 z-50 max-h-96 overflow-y-auto">
                        {searchResults.map((res, idx) => (
                            <div 
                                key={res.id} 
                                className={`px-4 py-2 cursor-pointer border-b border-gray-100 dark:border-gray-800 last:border-0 text-sm ${
                                    idx === activeSearchIndex ? 'bg-primary text-primary-foreground' : 'hover:bg-primary/10'
                                }`}
                                onClick={() => handleSearchSelect(res.id)}
                                onMouseEnter={() => setActiveSearchIndex(idx)}
                            >
                                {res.title}
                            </div>
                        ))}
                    </div>
                )}
            </div>

        </div>

        {/* Canvas Area - 3-COLUMN FLEX LAYOUT */}
        <div 
            ref={mainContainerRef}
            className="flex-1 bg-[var(--theme-bg)] p-3 overflow-hidden outline-none relative transition-colors duration-300" 
            tabIndex={0}
        >
            <div className="flex h-full w-full gap-3">
                
                {/* --- Left Column (25%) --- */}
                <div className="flex flex-col gap-3 w-1/4">
                    
                    {/* Related (Top Left) */}
                    <div className={`${showFavorites ? 'flex-1' : 'h-full'} relative bg-[var(--theme-section)] rounded-3xl shadow-lg border border-black/5 dark:border-white/5 min-h-0`}>
                        <div className={labelStyle} style={{ fontSize: `${Math.max(10, fontSize - 10)}px` }}>Related</div>
                        {renderSection(
                            topology.lefters, 
                            'left', 
                            'absolute inset-0 flex flex-col gap-0 overflow-y-auto p-3 custom-scrollbar rounded-3xl pt-6',
                            'w-full',
                            'container-left'
                        )}
                    </div>

                    {/* Favorites (Bottom Left) - Conditional */}
                    {showFavorites && (
                        <div className="flex-1 relative bg-[var(--theme-section)] rounded-3xl shadow-lg border border-black/5 dark:border-white/5 min-h-0">
                            <div className={labelStyle} style={{ fontSize: `${Math.max(10, fontSize - 10)}px` }}>Favorites</div>
                            {renderSection(
                                favorites, 
                                'favs', 
                                'absolute inset-0 flex flex-col gap-0 overflow-y-auto p-3 custom-scrollbar rounded-3xl pt-6',
                                'w-full',
                                'container-favs'
                            )}
                        </div>
                    )}
                </div>

                {/* --- Center Column (50%) --- */}
                <div className="flex flex-col gap-3 w-1/2">
                    
                    {/* Top Wrapper (Parents + Active) - flex-1 matches side columns' top section */}
                    <div className="flex-1 flex flex-col gap-3 min-h-0">
                        
                        {/* Parents (35% of column ~ 70% of wrapper) */}
                        <div className="flex-[7] relative bg-[var(--theme-section)] rounded-3xl shadow-lg border border-black/5 dark:border-white/5 min-h-0">
                             <div className={labelStyle} style={{ fontSize: `${Math.max(10, fontSize - 10)}px` }}>Parents</div>
                             <div className="absolute inset-0 overflow-x-auto overflow-y-hidden custom-scrollbar rounded-3xl pt-6">
                                {renderSection(
                                    topology.uppers, 
                                    'up', 
                                    'h-full w-fit flex flex-col flex-wrap content-start gap-0 p-3 mx-auto', 
                                    'w-[300px] flex-shrink-0',
                                    'container-up'
                                )}
                             </div>
                        </div>

                        {/* Active Note (15% of column ~ 30% of wrapper) */}
                        <div className="flex-[3] relative flex items-center justify-center p-4 z-10 bg-[var(--theme-section)] rounded-3xl shadow-lg border border-black/5 dark:border-white/5 min-h-0">
                            <div className={labelStyle} style={{ fontSize: `${Math.max(10, fontSize - 10)}px` }}>Active Note</div>
                            {topology.center && (
                                <>
                                    <NoteCard
                                        note={topology.center}
                                        fontSize={fontSize}
                                        isFocused={focusedSection === 'center'}
                                        isCenter={true}
                                        onClick={() => {}}
                                    />
                                    {/* Status Icons (Moved to Section Container) */}
                                    <div className="absolute bottom-4 right-4 flex gap-1 pointer-events-none">
                                        {topology.center.isFavorite && (
                                            <svg className="text-yellow-600 drop-shadow-sm" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>
                                        )}
                                        {topology.center.content && topology.center.content.trim().length > 0 && (
                                            <svg className="text-yellow-600 drop-shadow-sm" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
                                        )}
                                    </div>
                                </>
                            )}
                        </div>
                    </div>

                    {/* Children (Bot Center - 50%) */}
                    <div className="flex-1 relative bg-[var(--theme-section)] rounded-3xl shadow-lg border border-black/5 dark:border-white/5 min-h-0">
                        <div className={labelStyle} style={{ fontSize: `${Math.max(10, fontSize - 10)}px` }}>Children</div>
                        <div className="absolute inset-0 overflow-x-auto overflow-y-hidden custom-scrollbar rounded-3xl pt-6">
                            {renderSection(
                                topology.downers, 
                                'down', 
                                'h-full w-fit flex flex-col flex-wrap content-start gap-0 p-3 mx-auto', 
                                'w-[300px] flex-shrink-0',
                                'container-down'
                            )}
                        </div>
                    </div>
                </div>

                {/* --- Right Column (25%) --- */}
                <div className="flex flex-col gap-3 w-1/4">
                    
                    {/* Siblings (Top Right) */}
                    <div className={`${showContent ? 'flex-1' : 'h-full'} relative bg-[var(--theme-section)] rounded-3xl shadow-lg border border-black/5 dark:border-white/5 min-h-0`}>
                        <div className={labelStyle} style={{ fontSize: `${Math.max(10, fontSize - 10)}px` }}>Siblings</div>
                         {renderSection(
                            topology.righters, 
                            'right', 
                            'flex flex-col gap-0 overflow-y-auto p-3 h-full custom-scrollbar rounded-3xl pt-6', 
                            'w-full',
                            'container-right'
                        )}
                    </div>

                    {/* Content Preview (Bottom Right) - Conditional */}
                    {showContent && (
                        <div 
                            ref={contentPreviewRef}
                            className={`flex-1 relative bg-[var(--theme-section)] rounded-3xl shadow-lg border border-black/5 dark:border-white/5 min-h-0 outline-none ${focusedSection === 'content' ? 'ring-2 ring-[var(--theme-accent)]' : ''}`}
                            tabIndex={-1}
                        >
                             <div className={labelStyle} style={{ fontSize: `${Math.max(10, fontSize - 10)}px` }}>Content</div>
                             <div 
                                className="absolute inset-0 p-6 overflow-auto custom-scrollbar prose dark:prose-invert max-w-none rounded-3xl pt-8"
                                dangerouslySetInnerHTML={{ __html: previewHtml }}
                             />
                        </div>
                    )}
                </div>

            </div>
        </div>
        
        {/* --- Footer / Status Bar --- */}
        <div style={{ fontSize: `${uiFontSize}px` }} className="h-8 flex-shrink-0 bg-[var(--theme-bars)] flex items-center justify-between px-4 text-foreground z-50 transition-colors duration-300">
            <div className="flex-shrink-0 opacity-90">
                Notes: {totalNoteCount} | DB: {getCurrentVaultName()} 0.2.15
            </div>
            <div className="opacity-60 truncate ml-4 text-right">
                Arrows: Nav | Space: Open | Enter: Center Focus | Shift+Enter: Edit | Ctrl+Arrows: Link | F2: Rename | Bksp: Unlink
            </div>
        </div>

      </div>

      {/* --- Modals --- */}
      <LinkerModal 
        isOpen={linkerOpen} 
        type={linkerType} 
        onClose={() => setLinkerOpen(false)} 
        onSelect={handleLinkerSelect} 
      />
      <MarkdownEditor 
        isOpen={editorOpen}
        initialMode={editorMode}
        note={getFocusedNote()}
        onClose={() => setEditorOpen(false)}
        onSave={(id, content) => {
            updateNote(id, { content });
            loadTopology(centralNoteId);
        }}
      />
      <RenameModal
        isOpen={renameModalOpen}
        currentTitle={noteToRename?.title || ''}
        onClose={() => setRenameModalOpen(false)}
        onRename={handleRename}
      />
      <SettingsModal
        isOpen={settingsOpen}
        onClose={() => setSettingsOpen(false)}
        currentCentralNoteId={centralNoteId}
        fontSize={fontSize}
        onFontSizeChange={setFontSize}
        onThemeChange={() => setThemeTick(t => t + 1)}
        onSettingsChange={refreshSettings}
      />
    </div>
  );
}

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
    </script>
</body>
</html>